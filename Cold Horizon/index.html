<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cold Horizon 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            background: linear-gradient(180deg, #0a1929 0%, #1e3a5f 50%, #2d5aa0 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            height: 750px;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            border: 2px solid #334155;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }

        #gameCanvas {
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .top-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .score {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            color: #fbbf24;
            border: 2px solid #f59e0b;
        }

        .resources {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 15px;
            min-width: 120px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            font-size: 16px;
        }

        .resource-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .heat-fill { background: linear-gradient(90deg, #f97316 0%, #ea580c 100%); }
        .food-fill { background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%); }
        .shelter-fill { background: linear-gradient(90deg, #3b82f6 0%, #2563eb 100%); }

        /* Tycoon UI */
        .tycoon-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            min-width: 200px;
            color: white;
            font-weight: bold;
        }

        .money-display {
            font-size: 18px;
            color: #10b981;
            margin-bottom: 5px;
        }

        .income-display {
            font-size: 14px;
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .upgrade-info {
            font-size: 12px;
            color: #94a3b8;
            text-align: center;
            border-top: 1px solid #374151;
            padding-top: 8px;
        }

        /* Challenge UI */
        .challenge-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ef4444;
            min-width: 200px;
            color: white;
            font-weight: bold;
        }

        .timer-display {
            font-size: 18px;
            color: #ef4444;
            margin-bottom: 5px;
        }

        .target-display {
            font-size: 14px;
            color: #fbbf24;
            margin-bottom: 5px;
        }

        .breakdown-info {
            font-size: 12px;
            color: #f87171;
            margin-top: 8px;
            border-top: 1px solid #374151;
            padding-top: 8px;
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .game-over-screen.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .game-over-title {
            font-size: 48px;
            font-weight: bold;
            color: #60a5fa;
            text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
        }

        .final-score {
            font-size: 24px;
            color: #fbbf24;
        }

        .restart-btn {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s ease;
            pointer-events: all;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }


        /* Mobil Joystick */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .mobile-controls.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .joystick {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #3b82f6;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: 2px solid #ffffff;
            position: absolute;
            cursor: grab;
            transition: transform 0.1s ease;
        }

        .joystick-knob:active {
            cursor: grabbing;
        }

        /* Klavye kontrolleri g√∂stergesi ve Minimap kaldƒ±rƒ±ldƒ± */


        @media (max-width: 520px) {
            .game-container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Three.js CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        
        <div class="ui-overlay">
            <!-- Tycoon UI -->
            <div class="tycoon-ui" id="tycoonUI">
                <div class="money-display" id="moneyDisplay">üí∞ $100</div>
                <div class="income-display" id="incomeDisplay">üìà +$5/sn</div>
                <div class="upgrade-info" id="upgradeInfo">
                    üí° Daire platformlara √ßƒ±k ve upgrade satƒ±n al!
                </div>
            </div>

            <!-- Challenge UI -->
            <div class="challenge-ui" id="challengeUI">
                <div class="timer-display" id="timerDisplay">‚è∞ 5:00</div>
                <div class="target-display" id="targetDisplay">üéØ $5,000 hedef</div>
                <div class="target-display" id="incomeTargetDisplay">üìà $100/sn hedef</div>
                <div class="breakdown-info" id="breakdownInfo">
                    ‚ö†Ô∏è Makineler arƒ±zalanabilir!
                </div>
            </div>
            
            <div class="top-ui">
                <div class="score" id="scoreDisplay">Skor: 0</div>
                <!-- Resource barlarƒ± kaldƒ±rƒ±ldƒ± - sadece tycoon -->
            </div>


            <!-- Mobil Joystick -->
            <div class="mobile-controls" id="mobileControls">
                <div class="joystick">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>

            <!-- Klavye kontrol√º g√∂stergesi ve minimap kaldƒ±rƒ±ldƒ± -->

            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over-title">DONDU!</div>
                <div class="final-score" id="finalScore">Final Skor: 0</div>
                <button class="restart-btn" id="restartBtn">Yeniden Ba≈üla</button>
            </div>
        </div>
    </div>

    <script>
        // Farcade SDK Mock (ger√ßek SDK y√ºklendiƒüinde deƒüi≈ütirilecek)
        const Farcade = {
            ready: () => console.log('Farcade ready'),
            gameOver: (data) => console.log('Game over:', data),
            hapticFeedback: () => {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        };

        class ColdHorizon3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                
                // Canvas boyutlarƒ±nƒ± ayarla
                this.setupCanvas();
                
                // Three.js sahne olu≈ütur
                this.initThreeJS();
                
                // Oyun durumu - tycoon + challenge sistemi
                this.gameState = {
                    score: 0,
                    isGameOver: false,
                    gameWon: false,
                    timeLimit: 300, // 5 dakika (300 saniye)
                    startTime: Date.now(),
                    targetMoney: 5000, // Hedef para
                    targetIncome: 100, // Hedef gelir/saniye
                    challenges: {
                        breakdownChance: 0.001, // Makine arƒ±za olasƒ±lƒ±ƒüƒ±
                        lastBreakdown: 0,
                        brokenMachines: [],
                        repairCost: 50
                    }
                };

                // Tycoon sistemi
                this.tycoonState = {
                    money: 100, // Ba≈ülangƒ±√ß parasƒ±
                    moneyPerSecond: 5, // Saniyede kazanc
                    lastMoneyTime: Date.now(),
                    upgrades: [], // Satƒ±n alƒ±nan upgrade'ler
                    availableUpgrades: [
                        {
                            id: 'raw_material',
                            name: 'Hammadde Deposu',
                            price: 100,
                            position: { x: -6, z: 3 }, // Sol √ºst - ba≈ülangƒ±√ß
                            bought: false,
                            description: '+$5/sn',
                            step: 1,
                            requires: null,
                            info: 'Fabrika i√ßin hammadde tedarik eder'
                        },
                        {
                            id: 'conveyor_input',
                            name: 'Giri≈ü Konveyor√º',
                            price: 200,
                            position: { x: -3, z: 3 }, // Hammaddeden saƒüa
                            bought: false,
                            description: '+$3/sn',
                            step: 2,
                            requires: 'raw_material',
                            info: 'Hammaddeyi i≈üleme alanƒ±na ta≈üƒ±r'
                        },
                        {
                            id: 'processing_machine',
                            name: 'ƒ∞≈üleme Makinesi',
                            price: 400,
                            position: { x: 0, z: 3 }, // Merkez √ºst - ana i≈üleme
                            bought: false,
                            description: '+$10/sn',
                            step: 3,
                            requires: 'conveyor_input',
                            info: 'Hammaddeyi i≈üleyip √ºr√ºne √ßevirir'
                        },
                        {
                            id: 'quality_control',
                            name: 'Kalite Kontrol',
                            price: 600,
                            position: { x: 3, z: 3 }, // Saƒü √ºst
                            bought: false,
                            description: '+$8/sn',
                            step: 4,
                            requires: 'processing_machine',
                            info: '√úr√ºnlerin kalitesini kontrol eder'
                        },
                        {
                            id: 'packaging',
                            name: 'Paketleme √únitesi',
                            price: 1000,
                            position: { x: 3, z: -3 }, // Saƒü alt - L ≈üeklinde d√∂n√º≈ü
                            bought: false,
                            description: '+$15/sn',
                            step: 5,
                            requires: 'quality_control',
                            info: '√úr√ºnleri paketleyip satƒ±≈üa hazƒ±rlar'
                        },
                        {
                            id: 'shipping',
                            name: 'Kargo √únitesi',
                            price: 1500,
                            position: { x: -3, z: -3 }, // Sol alt - √ßƒ±kƒ±≈ü noktasƒ±
                            bought: false,
                            description: '+$25/sn',
                            step: 6,
                            requires: 'packaging',
                            info: 'Paketlenen √ºr√ºnleri m√º≈üterilere g√∂nderir'
                        }
                    ],
                    upgradePlatforms: [],
                    upgradeObjects: []
                };

                // 3D objeler
                this.sceneObjects = {
                    shelter: null,
                    fire: null,
                    survivors: [],
                    snowSystem: null,
                    player: null,
                    roads: [],
                    houses: [],
                    factoryFloor: null,
                    world: null,
                    tycoonPlatforms: [],
                    tycoonBuildings: []
                };

                // Hareket sistemi
                this.movement = {
                    keys: {
                        w: false, a: false, s: false, d: false,
                        ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
                    },
                    speed: 0.3,
                    joystick: { x: 0, y: 0 }
                };

                // Harita sistemi
                this.worldMap = {
                    width: 100,
                    height: 100,
                    playerPosition: { x: 0, y: 0, z: 0 }
                };

                // Minimap kaldƒ±rƒ±ldƒ±
                

                // Event listeners
                this.setupEventListeners();
                
                // 3D sahneyi olu≈ütur
                this.create3DScene();
                
                // Oyunu ba≈ülat
                this.startGame();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                this.width = rect.width;
                this.height = rect.height;
            }

            initThreeJS() {
                // Sahne olu≈ütur
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0f172a, 50, 200);

                // Kamera olu≈ütur (perspektif kamera)
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    this.width / this.height, 
                    0.1, 
                    1000
                );
                // Kamerayƒ± Y ekseni sabit kalacak ≈üekilde ters y√∂nde d√∂nd√ºr (yakƒ±nla≈ütƒ±rƒ±lmƒ±≈ü)
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // Kamera frustum ayarlarƒ±
                this.camera.far = 1000;
                this.camera.near = 0.1;
                
                // Kamerayƒ± tamamen sabitle
                this.camera.position.x = -15;
                this.camera.position.y = 20;
                this.camera.position.z = 15;

                // Renderer olu≈ütur
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: false,
                    logarithmicDepthBuffer: false
                });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = false; // G√∂lgeleri kapat
                this.renderer.setClearColor(0x0f172a, 1);
                
                // Render optimizasyonlarƒ±nƒ± kapat
                this.renderer.sortObjects = false;
                this.renderer.autoClear = true;
                
                // Frustum culling'i tamamen kapat
                this.renderer.setClearColor(0x0f172a, 1);
                this.scene.autoUpdate = true;

                // I≈üƒ±klandƒ±rma
                this.setupLighting();

                // Kamera kontrolleri
                this.setupCameraControls();
            }

            setupLighting() {
                // Ambient ƒ±≈üƒ±k (genel aydƒ±nlatma)
                const ambientLight = new THREE.AmbientLight(0x334155, 0.3);
                this.scene.add(ambientLight);

                // Direkt ƒ±≈üƒ±k (g√ºne≈ü)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Ate≈ü ƒ±≈üƒ±ƒüƒ± (point light)
                this.fireLight = new THREE.PointLight(0xf97316, 2, 15);
                this.fireLight.position.set(0, 2, 0);
                this.fireLight.castShadow = true;
                this.scene.add(this.fireLight);
            }

            setupCameraControls() {
                // Kamera tamamen sabit - hi√ßbir kontrol yok
            }

            setupEventListeners() {
                // Klavye kontrolleri
                document.addEventListener('keydown', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = true;
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = false;
                        e.preventDefault();
                    }
                });

                // Dokunmatik kontroller (artƒ±k sadece joystick i√ßin)

                // Yeniden ba≈ülat
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                    Farcade.hapticFeedback();
                });

                // Mobil joystick
                this.setupJoystick();

                // Mobil kontrolleri g√∂ster/gizle
                this.detectMobile();

                // Resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
            }

            detectMobile() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const mobileControls = document.getElementById('mobileControls');
                
                if (isMobile) {
                    mobileControls.classList.add('show');
                } else {
                    mobileControls.classList.remove('show');
                }
            }

            setupJoystick() {
                const joystick = document.getElementById('joystickKnob');
                let isDragging = false;
                let startPos = { x: 0, y: 0 };

                joystick.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                joystick.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    
                    const touch = e.touches[0];
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                    
                    e.preventDefault();
                });

                joystick.addEventListener('touchend', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });

                // Mouse desteƒüi (masa√ºst√º test i√ßin)
                joystick.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = e.clientX - centerX;
                    const deltaY = e.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });
            }

            // setupMinimap fonksiyonu kaldƒ±rƒ±ldƒ±

            create3DScene() {
                this.createWorld();
                this.createPlayer();
                this.createTycoonPlatforms();
                this.createSnowSystem();
                
                // T√ºm objeleri ba≈ütan render et
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
            }

            createWorld() {
                // T√ºm harita ba≈ütan y√ºklensin - b√ºy√ºk d√ºnya zemini
                const groundGeometry = new THREE.PlaneGeometry(this.worldMap.width, this.worldMap.height);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1e293b,
                    transparent: false,
                    opacity: 1.0
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                ground.frustumCulled = false; // T√ºm harita her zaman g√∂r√ºn√ºr
                ground.visible = true;
                this.scene.add(ground);

                // T√ºm kar zemini y√ºklensin
                const snowGeometry = new THREE.PlaneGeometry(this.worldMap.width + 20, this.worldMap.height + 20);
                const snowMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf8fafc,
                    transparent: true,
                    opacity: 0.6
                });
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                snow.rotation.x = -Math.PI / 2;
                snow.position.y = 0.01;
                snow.frustumCulled = false; // T√ºm kar zemini her zaman g√∂r√ºn√ºr
                snow.visible = true;
                this.scene.add(snow);

                // D√ºnya sƒ±nƒ±rlarƒ± (g√∂r√ºnmez duvarlar)
                this.createWorldBounds();

                this.sceneObjects.world = { ground, snow };
            }

            createWorldBounds() {
                // D√ºnya sƒ±nƒ±rlarƒ± i√ßin g√∂r√ºnmez duvarlar
                const bounds = [
                    { pos: [0, 25, this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // Arka
                    { pos: [0, 25, -this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // √ñn
                    { pos: [this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }, // Saƒü
                    { pos: [-this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }  // Sol
                ];

                bounds.forEach(bound => {
                    const geometry = new THREE.BoxGeometry(bound.size[0], bound.size[1], bound.size[2]);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0 
                    });
                    const wall = new THREE.Mesh(geometry, material);
                    wall.position.set(bound.pos[0], bound.pos[1], bound.pos[2]);
                    wall.userData = { isBoundary: true };
                    wall.frustumCulled = false; // Frustum culling'i devre dƒ±≈üƒ± bƒ±rak
                    this.scene.add(wall);
                });
            }

            createTycoonPlatforms() {
                console.log("Tycoon platformlarƒ± olu≈üturuluyor...");
                
                this.tycoonState.availableUpgrades.forEach(upgrade => {
                    // Platform olu≈ütur
                    const platformGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.2, 16);
                    let platformColor = 0xff6b35; // Turuncu - satƒ±n alƒ±nabilir
                    
                    if (upgrade.bought) {
                        platformColor = 0x10b981; // Ye≈üil - satƒ±n alƒ±nmƒ±≈ü
                    } else if (upgrade.requires && !this.isUpgradeBought(upgrade.requires)) {
                        platformColor = 0x6b7280; // Gri - hen√ºz satƒ±n alƒ±namaz
                    }
                    
                    const platformMaterial = new THREE.MeshLambertMaterial({ 
                        color: platformColor,
                        transparent: false,
                        opacity: 0.8
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    
                    platform.position.set(upgrade.position.x, 0.1, upgrade.position.z);
                    platform.userData = { 
                        type: 'upgradePlatform',
                        upgradeId: upgrade.id,
                        upgrade: upgrade
                    };
                    
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    platform.frustumCulled = false;
                    
                    this.scene.add(platform);
                    this.sceneObjects.tycoonPlatforms.push(platform);
                    this.tycoonState.upgradePlatforms.push(platform);
                    
                    // Platform √ºzerinde bilgi etiketi olu≈ütur
                    if (!upgrade.bought) {
                        this.createUpgradeLabel(upgrade);
                    }
                    
                    console.log(`Platform olu≈üturuldu: ${upgrade.name} - $${upgrade.price}`);
                });
                
                console.log(`Toplam ${this.tycoonState.upgradePlatforms.length} tycoon platformƒ± olu≈üturuldu`);
                
                // Production line baƒülantƒ±larƒ±nƒ± √ßiz
                this.createProductionConnections();
            }

            createProductionConnections() {
                console.log("Production line baƒülantƒ±larƒ± olu≈üturuluyor...");
                
                // Upgrade sƒ±rasƒ±na g√∂re baƒülantƒ± √ßizgileri olu≈ütur
                for (let i = 1; i < this.tycoonState.availableUpgrades.length; i++) {
                    const currentUpgrade = this.tycoonState.availableUpgrades[i];
                    const previousUpgrade = this.tycoonState.availableUpgrades[i - 1];
                    
                    this.createConnectionLine(previousUpgrade.position, currentUpgrade.position);
                }
            }

            createConnectionLine(pos1, pos2) {
                // ƒ∞ki nokta arasƒ±nda baƒülantƒ± √ßizgisi olu≈ütur
                const distance = Math.sqrt(
                    Math.pow(pos2.x - pos1.x, 2) + 
                    Math.pow(pos2.z - pos1.z, 2)
                );
                
                const connectionGeometry = new THREE.CylinderGeometry(0.1, 0.1, distance, 8);
                const connectionMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4b5563, // Gri baƒülantƒ± √ßizgisi
                    transparent: true,
                    opacity: 0.6
                });
                const connection = new THREE.Mesh(connectionGeometry, connectionMaterial);
                
                // √áizgiyi iki noktanƒ±n ortasƒ±na yerle≈ütir
                connection.position.set(
                    (pos1.x + pos2.x) / 2,
                    0.2,
                    (pos1.z + pos2.z) / 2
                );
                
                // √áizgiyi doƒüru a√ßƒ±ya √ßevir
                const angle = Math.atan2(pos2.z - pos1.z, pos2.x - pos1.x);
                connection.rotation.y = angle - Math.PI / 2;
                connection.rotation.z = Math.PI / 2;
                
                connection.userData = { type: 'connection' };
                connection.frustumCulled = false;
                
                this.scene.add(connection);
                this.sceneObjects.tycoonBuildings.push(connection);
            }

            createUpgradeLabel(upgrade) {
                // Upgrade bilgi etiketi olu≈ütur
                const labelGeometry = new THREE.BoxGeometry(3, 0.8, 0.1);
                let labelColor = 0x1f2937; // Koyu gri - normal
                
                if (upgrade.requires && !this.isUpgradeBought(upgrade.requires)) {
                    labelColor = 0x7f1d1d; // Koyu kƒ±rmƒ±zƒ± - kilitli
                }
                
                const labelMaterial = new THREE.MeshLambertMaterial({ 
                    color: labelColor,
                    transparent: true,
                    opacity: 0.9
                });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                
                label.position.set(upgrade.position.x, 2, upgrade.position.z + 1);
                label.userData = { 
                    type: 'upgradeLabel',
                    upgradeId: upgrade.id,
                    upgrade: upgrade
                };
                
                this.scene.add(label);
                this.sceneObjects.tycoonBuildings.push(label);
                
                // Adƒ±m numarasƒ± g√∂stergesi ekle
                this.createStepIndicator(upgrade);
            }

            createStepIndicator(upgrade) {
                // Adƒ±m numarasƒ± i√ßin k√º√ß√ºk daire
                const stepGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                const stepMaterial = new THREE.MeshLambertMaterial({ 
                    color: upgrade.bought ? 0x10b981 : 0xfbbf24,
                    emissive: upgrade.bought ? 0x003300 : 0x332200
                });
                const stepIndicator = new THREE.Mesh(stepGeometry, stepMaterial);
                
                stepIndicator.position.set(upgrade.position.x - 1, 0.3, upgrade.position.z - 1);
                stepIndicator.userData = { 
                    type: 'stepIndicator',
                    step: upgrade.step,
                    upgradeId: upgrade.id
                };
                
                this.scene.add(stepIndicator);
                this.sceneObjects.tycoonBuildings.push(stepIndicator);
            }

            isUpgradeBought(upgradeId) {
                const upgrade = this.tycoonState.availableUpgrades.find(u => u.id === upgradeId);
                return upgrade ? upgrade.bought : false;
            }

            createPlayer() {
                // ƒ∞nsan ≈üeklinde oyuncu karakteri olu≈ütur
                const player = new THREE.Group();
                
                // V√ºcut (ana g√∂vde) - daha b√ºy√ºk
                const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.4, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3b82f6 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                body.castShadow = true;
                player.add(body);

                // Kafa - daha b√ºy√ºk
                const headGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.0;
                head.castShadow = true;
                player.add(head);

                // Sa√ß - daha b√ºy√ºk
                const hairGeometry = new THREE.SphereGeometry(0.54, 8, 6);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 3.1;
                hair.scale.y = 0.7;
                player.add(hair);

                // Sol kol - daha b√ºy√ºk
                const leftArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
                leftArm.position.set(-0.8, 1.6, 0);
                leftArm.rotation.z = 0.3;
                leftArm.castShadow = true;
                player.add(leftArm);

                // Saƒü kol - daha b√ºy√ºk
                const rightArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
                rightArm.position.set(0.8, 1.6, 0);
                rightArm.rotation.z = -0.3;
                rightArm.castShadow = true;
                player.add(rightArm);

                // Sol bacak - daha b√ºy√ºk
                const leftLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                const leftLeg = new THREE.Mesh(leftLegGeometry, legMaterial);
                leftLeg.position.set(-0.3, -1.0, 0);
                leftLeg.castShadow = true;
                player.add(leftLeg);

                // Saƒü bacak - daha b√ºy√ºk
                const rightLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const rightLeg = new THREE.Mesh(rightLegGeometry, legMaterial);
                rightLeg.position.set(0.3, -1.0, 0);
                rightLeg.castShadow = true;
                player.add(rightLeg);

                // Ayaklar - daha b√ºy√ºk
                const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.8);
                const footMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                
                const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                leftFoot.position.set(-0.3, -2.1, 0.2);
                leftFoot.castShadow = true;
                player.add(leftFoot);

                const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                rightFoot.position.set(0.3, -2.1, 0.2);
                rightFoot.castShadow = true;
                player.add(rightFoot);

                // Oyuncuyu sahneye ekle - ba≈ülangƒ±√ß pozisyonu 0,0,0
                player.position.set(0, 0, 0);
                this.scene.add(player);

                this.sceneObjects.player = player;
            }


            createResourcePoints() {
                // Kaynak sistemi kaldƒ±rƒ±ldƒ± - sadece tycoon
                console.log("Kaynak sistemi kaldƒ±rƒ±ldƒ±");
            }

            createRoads() {
                // Yol sistemi kaldƒ±rƒ±ldƒ±
                console.log("Yollar kaldƒ±rƒ±ldƒ±");
            }

            createSimpleRoad(x, y, z, width, length, material) {
                // Yol olu≈üturma fonksiyonu kaldƒ±rƒ±ldƒ±
                return null;
            }

            createFactoryFloor() {
                // Fabrika zemini kaldƒ±rƒ±ldƒ±
                console.log("Fabrika zemini kaldƒ±rƒ±ldƒ±");
                this.sceneObjects.factoryFloor = null;
            }

            createHouses() {
                // Ev sistemi kaldƒ±rƒ±ldƒ±
                console.log("Evler kaldƒ±rƒ±ldƒ±");
            }

            isPositionOnRoad(x, z, roadSpacing) {
                // Yol kontrol√º kaldƒ±rƒ±ldƒ± - artƒ±k yol yok
                return false;
            }

            createHouse(x, z, material) {
                // Ev olu≈üturma fonksiyonu kaldƒ±rƒ±ldƒ±
                return null;
            }

            createGoldCoins() {
                // Altƒ±n sistemi kaldƒ±rƒ±ldƒ± - sadece tycoon
                console.log("Altƒ±n sistemi kaldƒ±rƒ±ldƒ±");
            }

            createShelter() {
                // Barƒ±nak duvarlarƒ±
                const wallGeometry = new THREE.BoxGeometry(8, 4, 6);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x475569 });
                
                // Arka duvar
                const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
                backWall.position.set(0, 2, -3);
                backWall.castShadow = true;
                this.scene.add(backWall);

                // Sol duvar
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                leftWall.position.set(-4, 2, 0);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.castShadow = true;
                this.scene.add(leftWall);

                // Saƒü duvar
                const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
                rightWall.position.set(4, 2, 0);
                rightWall.rotation.y = Math.PI / 2;
                rightWall.castShadow = true;
                this.scene.add(rightWall);

                // √áatƒ±
                const roofGeometry = new THREE.ConeGeometry(6, 3, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x64748b });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 5, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                this.scene.add(roof);

                this.sceneObjects.shelter = { backWall, leftWall, rightWall, roof };
            }


            createFire() {
                // Ate≈ü geometrisi
                const fireGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                const fireMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf97316,
                    emissive: 0xf97316,
                    emissiveIntensity: 0.5
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set(0, 1, 0);
                fire.castShadow = true;
                this.scene.add(fire);

                // Ate≈ü partik√ºlleri
                const particleCount = 50;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 2;
                    positions[i * 3 + 1] = Math.random() * 3;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

                    const color = new THREE.Color();
                    color.setHSL(0.1, 1, Math.random() * 0.5 + 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: false,
                    opacity: 0.8
                });

                const fireParticles = new THREE.Points(particles, particleMaterial);
                fireParticles.position.set(0, 1, 0);
                this.scene.add(fireParticles);

                this.sceneObjects.fire = { fire, particles: fireParticles };
            }

            createSurvivors() {
                // Survivor sistemi kaldƒ±rƒ±ldƒ± - sadece tycoon
                console.log("Survivor sistemi kaldƒ±rƒ±ldƒ±");
            }

            // addSurvivor fonksiyonu kaldƒ±rƒ±ldƒ±

            createSnowSystem() {
                // Kar sistemi - ba≈ütan render et, t√ºm harita alanƒ±na
                const snowCount = 2000; // Daha fazla kar par√ßacƒ±ƒüƒ±
                const snowGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(snowCount * 3);
                const velocities = new Float32Array(snowCount);

                // T√ºm harita alanƒ±na kar par√ßacƒ±klarƒ± yerle≈ütir
                for (let i = 0; i < snowCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * (this.worldMap.width + 50);
                    positions[i * 3 + 1] = Math.random() * 80 + 20; // Daha y√ºksekten ba≈üla
                    positions[i * 3 + 2] = (Math.random() - 0.5) * (this.worldMap.height + 50);
                    velocities[i] = Math.random() * 2 + 1;
                }

                snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

                const snowMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.9
                });

                const snowSystem = new THREE.Points(snowGeometry, snowMaterial);
                snowSystem.frustumCulled = false; // Her zaman render et
                snowSystem.visible = true;
                this.scene.add(snowSystem);
                
                this.sceneObjects.snowSystem = snowSystem;
            }

            startGame() {
                this.gameLoop();
                this.updateTycoonUI(); // Tycoon UI'yi ba≈ülat
                this.updatePlatformColors(); // Platform renklerini g√ºncelle
                Farcade.ready();
            }

            gameLoop() {
                if (this.gameState.isGameOver) return;

                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                // Oyun bitti mi kontrol et
                if (this.gameState.isGameOver || this.gameState.gameWon) return;
                
                // Tycoon sistemini g√ºncelle
                this.updateTycoonSystem();
                
                // Challenge sistemini g√ºncelle
                this.updateChallenges();
                
                // Zaman ve hedef kontrol√º
                this.checkWinLoseConditions();

                // Oyuncu hareketi
                this.updatePlayerMovement();

                // 3D animasyonlarƒ± g√ºncelle
                this.update3DAnimations();

                // Minimap kaldƒ±rƒ±ldƒ±
            }

            updateTycoonSystem() {
                const now = Date.now();
                const timeSinceLastMoney = now - this.tycoonState.lastMoneyTime;
                
                // Her saniyede para √ºret (arƒ±zalƒ± makineler hari√ß)
                if (timeSinceLastMoney >= 1000) {
                    let actualIncome = this.tycoonState.moneyPerSecond;
                    
                    // Arƒ±zalƒ± makinelerin gelirini d√º≈ü√ºr
                    this.gameState.challenges.brokenMachines.forEach(machineId => {
                        const upgrade = this.tycoonState.availableUpgrades.find(u => u.id === machineId);
                        if (upgrade) {
                            const lostIncome = parseInt(upgrade.description.match(/\d+/)[0]);
                            actualIncome -= lostIncome;
                        }
                    });
                    
                    actualIncome = Math.max(actualIncome, 0);
                    this.tycoonState.money += actualIncome;
                    this.tycoonState.lastMoneyTime = now;
                    this.updateTycoonUI();
                }
                
                // Platform √ßarpƒ±≈üma kontrol√º
                this.checkPlatformCollisions();
            }

            updateTycoonUI() {
                // Para ve gelir g√∂stergesi
                document.getElementById('moneyDisplay').textContent = `üí∞ $${this.tycoonState.money.toLocaleString()}`;
                
                // Arƒ±zalƒ± makineler varsa geliri ayarla
                let actualIncome = this.tycoonState.moneyPerSecond;
                this.gameState.challenges.brokenMachines.forEach(machineId => {
                    const upgrade = this.tycoonState.availableUpgrades.find(u => u.id === machineId);
                    if (upgrade) {
                        const lostIncome = parseInt(upgrade.description.match(/\d+/)[0]);
                        actualIncome -= lostIncome;
                    }
                });
                actualIncome = Math.max(actualIncome, 0);
                
                document.getElementById('incomeDisplay').textContent = `üìà +$${actualIncome}/sn`;
                
                // Fabrika ilerleme durumunu g√∂ster
                const completedSteps = this.tycoonState.availableUpgrades.filter(u => u.bought).length;
                const totalSteps = this.tycoonState.availableUpgrades.length;
                const nextUpgrade = this.getNextAvailableUpgrade();
                
                let infoText = `üè≠ Fabrika: ${completedSteps}/${totalSteps} Tamamlandƒ±`;
                if (nextUpgrade) {
                    infoText += `<br>üîÑ Sonraki: ${nextUpgrade.name} ($${nextUpgrade.price})`;
                    if (nextUpgrade.requires && !this.isUpgradeBought(nextUpgrade.requires)) {
                        const requiredUpgrade = this.tycoonState.availableUpgrades.find(u => u.id === nextUpgrade.requires);
                        infoText += `<br>‚ö†Ô∏è √ñnce: ${requiredUpgrade.name}`;
                    }
                }
                
                document.getElementById('upgradeInfo').innerHTML = infoText;
                
                // Challenge UI g√ºncelle
                this.updateChallengeUI();
            }

            updateChallengeUI() {
                const now = Date.now();
                const elapsedTime = (now - this.gameState.startTime) / 1000;
                const remainingTime = Math.max(0, this.gameState.timeLimit - elapsedTime);
                
                // Zaman sayacƒ±
                const minutes = Math.floor(remainingTime / 60);
                const seconds = Math.floor(remainingTime % 60);
                const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timerDisplay').textContent = `‚è∞ ${timeText}`;
                
                // Hedef g√∂stergeleri
                const moneyProgress = Math.min(100, (this.tycoonState.money / this.gameState.targetMoney) * 100);
                const incomeProgress = Math.min(100, (this.tycoonState.moneyPerSecond / this.gameState.targetIncome) * 100);
                
                document.getElementById('targetDisplay').textContent = `üéØ $${this.gameState.targetMoney} hedef (${moneyProgress.toFixed(1)}%)`;
                document.getElementById('incomeTargetDisplay').textContent = `üìà $${this.gameState.targetIncome}/sn hedef (${incomeProgress.toFixed(1)}%)`;
                
                // Arƒ±za bilgisi
                let breakdownText = '‚öôÔ∏è T√ºm makineler √ßalƒ±≈üƒ±yor';
                if (this.gameState.challenges.brokenMachines.length > 0) {
                    breakdownText = `‚ö†Ô∏è ${this.gameState.challenges.brokenMachines.length} makine arƒ±zalƒ±!<br>üîß Tamir: $${this.gameState.challenges.repairCost}`;
                }
                document.getElementById('breakdownInfo').innerHTML = breakdownText;
            }

            getNextAvailableUpgrade() {
                return this.tycoonState.availableUpgrades
                    .filter(u => !u.bought)
                    .sort((a, b) => a.step - b.step)[0];
            }

            updateChallenges() {
                const now = Date.now();
                
                // Makine arƒ±za sistemi
                if (Math.random() < this.gameState.challenges.breakdownChance && 
                    now - this.gameState.challenges.lastBreakdown > 30000) { // En az 30 saniye ara
                    
                    // Satƒ±n alƒ±nmƒ±≈ü makinelerden birini arƒ±zalƒ± yap
                    const boughtUpgrades = this.tycoonState.availableUpgrades.filter(u => 
                        u.bought && !this.gameState.challenges.brokenMachines.includes(u.id)
                    );
                    
                    if (boughtUpgrades.length > 0) {
                        const randomMachine = boughtUpgrades[Math.floor(Math.random() * boughtUpgrades.length)];
                        this.gameState.challenges.brokenMachines.push(randomMachine.id);
                        this.gameState.challenges.lastBreakdown = now;
                        
                        console.log(`‚ö†Ô∏è ${randomMachine.name} arƒ±zalandƒ±! Tamir i√ßin $${this.gameState.challenges.repairCost} gerekli.`);
                        
                        // Makineyi kƒ±rmƒ±zƒ±ya boyayarak arƒ±za g√∂ster
                        this.showMachineBreakdown(randomMachine.id);
                    }
                }
                
                // Arƒ±zalƒ± makineleri otomatik tamir et (para varsa)
                if (this.gameState.challenges.brokenMachines.length > 0 && 
                    this.tycoonState.money >= this.gameState.challenges.repairCost) {
                    
                    const machineId = this.gameState.challenges.brokenMachines[0];
                    const upgrade = this.tycoonState.availableUpgrades.find(u => u.id === machineId);
                    
                    if (upgrade) {
                        this.tycoonState.money -= this.gameState.challenges.repairCost;
                        this.gameState.challenges.brokenMachines.shift();
                        
                        console.log(`üîß ${upgrade.name} tamir edildi! -$${this.gameState.challenges.repairCost}`);
                        
                        // Makine rengini normale d√∂nd√ºr
                        this.fixMachineBreakdown(machineId);
                    }
                }
            }

            showMachineBreakdown(machineId) {
                // Arƒ±zalƒ± makineyi kƒ±rmƒ±zƒ±ya boyar
                this.sceneObjects.tycoonBuildings.forEach(building => {
                    if (building.userData.upgradeId === machineId) {
                        building.material.color.setHex(0xff0000); // Kƒ±rmƒ±zƒ±
                        building.material.emissive.setHex(0x330000); // Hafif kƒ±rmƒ±zƒ± parƒ±ltƒ±
                    }
                });
            }

            fixMachineBreakdown(machineId) {
                // Makine rengini normale d√∂nd√ºr
                const upgrade = this.tycoonState.availableUpgrades.find(u => u.id === machineId);
                if (!upgrade) return;
                
                this.sceneObjects.tycoonBuildings.forEach(building => {
                    if (building.userData.upgradeId === machineId) {
                        // Orijinal renge d√∂nd√ºr
                        switch(machineId) {
                            case 'raw_material': building.material.color.setHex(0x8B4513); break;
                            case 'conveyor_input': building.material.color.setHex(0x2F4F4F); break;
                            case 'processing_machine': building.material.color.setHex(0x4682B4); break;
                            case 'quality_control': building.material.color.setHex(0x32CD32); break;
                            case 'packaging': building.material.color.setHex(0xFF8C00); break;
                            case 'shipping': building.material.color.setHex(0xDC143C); break;
                        }
                        building.material.emissive.setHex(0x000000); // Parƒ±ltƒ±yƒ± kaldƒ±r
                    }
                });
            }

            checkWinLoseConditions() {
                const now = Date.now();
                const elapsedTime = (now - this.gameState.startTime) / 1000; // Saniye
                const remainingTime = Math.max(0, this.gameState.timeLimit - elapsedTime);
                
                // Zaman doldu - KAYBƒ∞
                if (remainingTime <= 0) {
                    this.gameState.isGameOver = true;
                    this.showGameOver(false, 'Zaman doldu!');
                    return;
                }
                
                // Hedef para ula≈üƒ±ldƒ± - KAZANƒ∞M
                if (this.tycoonState.money >= this.gameState.targetMoney) {
                    this.gameState.gameWon = true;
                    this.showGameOver(true, `Tebrikler! $${this.gameState.targetMoney} hedefe ula≈ütƒ±n!`);
                    return;
                }
                
                // Hedef gelir ula≈üƒ±ldƒ± - KAZANƒ∞M
                if (this.tycoonState.moneyPerSecond >= this.gameState.targetIncome) {
                    this.gameState.gameWon = true;
                    this.showGameOver(true, `Tebrikler! $${this.gameState.targetIncome}/sn gelir hedefe ula≈ütƒ±n!`);
                    return;
                }
            }

            showGameOver(won, message) {
                const gameOverScreen = document.getElementById('gameOverScreen');
                const gameOverTitle = document.querySelector('.game-over-title');
                const finalScore = document.getElementById('finalScore');
                
                if (won) {
                    gameOverTitle.textContent = 'TEBRƒ∞KLER!';
                    gameOverTitle.style.color = '#10b981'; // Ye≈üil
                    finalScore.textContent = message;
                } else {
                    gameOverTitle.textContent = 'OYUN Bƒ∞TTƒ∞!';
                    gameOverTitle.style.color = '#ef4444'; // Kƒ±rmƒ±zƒ±
                    finalScore.textContent = message;
                }
                
                gameOverScreen.classList.add('show');
                
                // Farcade'e bildir
                Farcade.gameOver({ 
                    score: this.tycoonState.money,
                    won: won,
                    message: message
                });
            }

            checkPlatformCollisions() {
                if (!this.sceneObjects.player) return;
                
                const playerPos = this.sceneObjects.player.position;
                const collisionRange = 1.5;
                
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const platformPos = platform.position;
                    
                    // Oyuncu merkezde olduƒüu i√ßin platform pozisyonuna g√∂re mesafe hesapla
                    const distance = Math.sqrt(
                        Math.pow(platformPos.x, 2) + 
                        Math.pow(platformPos.z, 2)
                    );
                    
                    if (distance < collisionRange) {
                        const upgrade = platform.userData.upgrade;
                        
                        if (!upgrade.bought && this.canPurchaseUpgrade(upgrade)) {
                            this.purchaseUpgrade(upgrade, platform);
                        }
                    }
                });
            }

            canPurchaseUpgrade(upgrade) {
                // Para kontrol√º
                if (this.tycoonState.money < upgrade.price) {
                    return false;
                }
                
                // √ñn ko≈üul kontrol√º - sƒ±ralƒ± upgrade sistemi
                if (upgrade.requires) {
                    const requiredUpgrade = this.tycoonState.availableUpgrades.find(u => u.id === upgrade.requires);
                    if (!requiredUpgrade || !requiredUpgrade.bought) {
                        console.log(`‚ö†Ô∏è √ñnce ${requiredUpgrade ? requiredUpgrade.name : upgrade.requires} satƒ±n almalƒ±sƒ±nƒ±z!`);
                        return false;
                    }
                }
                
                return true;
            }

            purchaseUpgrade(upgrade, platform) {
                console.log(`Upgrade satƒ±n alƒ±nƒ±yor: ${upgrade.name} - $${upgrade.price}`);
                
                // Parayƒ± d√º≈ü
                this.tycoonState.money -= upgrade.price;
                
                // Upgrade'ƒ± satƒ±n alƒ±nmƒ±≈ü olarak i≈üaretle
                upgrade.bought = true;
                
                // Geliri artƒ±r
                const incomeIncrease = parseInt(upgrade.description.match(/\d+/)[0]);
                this.tycoonState.moneyPerSecond += incomeIncrease;
                
                // Platform rengini deƒüi≈ütir
                platform.material.color.setHex(0x10b981); // Ye≈üil
                
                // Upgrade objesi olu≈ütur
                this.createUpgradeObject(upgrade);
                
                // Upgrade etiketini kaldƒ±r
                this.removeUpgradeLabel(upgrade.id);
                
                // Sonraki upgrade'lerin rengini g√ºncelle
                this.updatePlatformColors();
                
                // UI g√ºncelle
                this.updateTycoonUI();
                
                // Haptic feedback
                if (typeof Farcade !== 'undefined' && Farcade.hapticFeedback) {
                    Farcade.hapticFeedback();
                }
                
                console.log(`‚úÖ ${upgrade.name} satƒ±n alƒ±ndƒ±! Yeni gelir: +$${this.tycoonState.moneyPerSecond}/sn`);
            }

            createUpgradeObject(upgrade) {
                let geometry, material, mesh;
                
                switch(upgrade.id) {
                    case 'raw_material':
                        // Hammadde deposu - b√ºy√ºk dikd√∂rtgen depo
                        geometry = new THREE.BoxGeometry(2, 2.5, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Kahverengi
                        break;
                    case 'conveyor_input':
                        // Konveyor bant - uzun ve d√º≈ü√ºk
                        geometry = new THREE.BoxGeometry(2.5, 0.3, 0.8);
                        material = new THREE.MeshLambertMaterial({ color: 0x2F4F4F }); // Koyu gri
                        break;
                    case 'processing_machine':
                        // ƒ∞≈üleme makinesi - karma≈üƒ±k makine g√∂r√ºn√ºm√º
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x4682B4 }); // √áelik mavisi
                        break;
                    case 'quality_control':
                        // Kalite kontrol - y√ºksek ince makine
                        geometry = new THREE.BoxGeometry(1.5, 2.5, 1.5);
                        material = new THREE.MeshLambertMaterial({ color: 0x32CD32 }); // Ye≈üil
                        break;
                    case 'packaging':
                        // Paketleme √ºnitesi - orta boy kare
                        geometry = new THREE.BoxGeometry(2.2, 1.8, 2.2);
                        material = new THREE.MeshLambertMaterial({ color: 0xFF8C00 }); // Turuncu
                        break;
                    case 'shipping':
                        // Kargo √ºnitesi - b√ºy√ºk y√ºkleme rampasƒ±
                        geometry = new THREE.BoxGeometry(3, 2.5, 2.5);
                        material = new THREE.MeshLambertMaterial({ color: 0xDC143C }); // Kƒ±rmƒ±zƒ±
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                }
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(upgrade.position.x, geometry.parameters ? geometry.parameters.height/2 : 1, upgrade.position.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: 'upgradeObject', upgradeId: upgrade.id };
                
                this.scene.add(mesh);
                this.sceneObjects.tycoonBuildings.push(mesh);
                this.tycoonState.upgradeObjects.push(mesh);
                
                // Fabrika makineleri i√ßin ek detaylar ekle
                this.addMachineDetails(upgrade, mesh);
            }

            addMachineDetails(upgrade, mainMesh) {
                const position = mainMesh.position;
                
                switch(upgrade.id) {
                    case 'processing_machine':
                        // Makine √ºst√ºnde boru sistemi
                        const pipe = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, 1, 8),
                            new THREE.MeshLambertMaterial({ color: 0x708090 })
                        );
                        pipe.position.set(position.x, position.y + 1.5, position.z);
                        pipe.castShadow = true;
                        this.scene.add(pipe);
                        this.sceneObjects.tycoonBuildings.push(pipe);
                        break;
                        
                    case 'quality_control':
                        // Kalite kontrol i√ßin tarayƒ±cƒ± ƒ±≈üƒ±k
                        const scanner = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.3, 1.8),
                            new THREE.MeshLambertMaterial({ color: 0x00FF00, emissive: 0x003300 })
                        );
                        scanner.position.set(position.x, position.y + 0.8, position.z);
                        scanner.castShadow = true;
                        this.scene.add(scanner);
                        this.sceneObjects.tycoonBuildings.push(scanner);
                        break;
                        
                    case 'shipping':
                        // Kargo i√ßin y√ºkleme rampasƒ±
                        const ramp = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 0.2, 3),
                            new THREE.MeshLambertMaterial({ color: 0x696969 })
                        );
                        ramp.position.set(position.x + 1.5, position.y - 1, position.z);
                        ramp.rotation.z = -0.3;
                        ramp.castShadow = true;
                        this.scene.add(ramp);
                        this.sceneObjects.tycoonBuildings.push(ramp);
                        break;
                }
            }

            removeUpgradeLabel(upgradeId) {
                // Upgrade etiketini ve step indicator'ƒ± bul ve kaldƒ±r
                for (let i = this.sceneObjects.tycoonBuildings.length - 1; i >= 0; i--) {
                    const building = this.sceneObjects.tycoonBuildings[i];
                    if ((building.userData.type === 'upgradeLabel' || building.userData.type === 'stepIndicator') && 
                        building.userData.upgradeId === upgradeId) {
                        this.scene.remove(building);
                        this.sceneObjects.tycoonBuildings.splice(i, 1);
                    }
                }
            }

            updatePlatformColors() {
                // T√ºm platformlarƒ±n renklerini g√ºncelle
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const upgrade = platform.userData.upgrade;
                    let newColor = 0xff6b35; // Turuncu - satƒ±n alƒ±nabilir
                    
                    if (upgrade.bought) {
                        newColor = 0x10b981; // Ye≈üil - satƒ±n alƒ±nmƒ±≈ü
                    } else if (upgrade.requires && !this.isUpgradeBought(upgrade.requires)) {
                        newColor = 0x6b7280; // Gri - hen√ºz satƒ±n alƒ±namaz
                    }
                    
                    platform.material.color.setHex(newColor);
                });
            }

            updatePlayerMovement() {
                if (!this.sceneObjects.player) return;

                let moveX = 0;
                let moveZ = 0;

                // Kamera a√ßƒ±sƒ±na g√∂re hareket eksenlerini ayarla
                // Kamera (-15, 20, 15) pozisyonunda, merkeze bakƒ±yor
                // Bu y√ºzden hareket eksenlerini kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re ayarlayalƒ±m
                const cameraAngle = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ± (g√ºncellenmi≈ü)

                // Klavye kontrolleri - kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re (d√ºzeltilmi≈ü y√∂nler)
                if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                    // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                    moveX -= Math.sin(cameraAngle) * this.movement.speed;
                    moveZ -= Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                    // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                    moveX += Math.sin(cameraAngle) * this.movement.speed;
                    moveZ += Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                    // Sol - kameranƒ±n soluna doƒüru
                    moveX -= Math.cos(cameraAngle) * this.movement.speed;
                    moveZ += Math.sin(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                    // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                    moveX += Math.cos(cameraAngle) * this.movement.speed;
                    moveZ -= Math.sin(cameraAngle) * this.movement.speed;
                }

                // Joystick kontrolleri - d√ºzeltilmi≈ü eksen sistemi
                moveX -= this.movement.joystick.x * Math.cos(cameraAngle) * this.movement.speed;
                moveZ += this.movement.joystick.x * Math.sin(cameraAngle) * this.movement.speed;
                moveX -= this.movement.joystick.y * Math.sin(cameraAngle) * this.movement.speed;
                moveZ -= this.movement.joystick.y * Math.cos(cameraAngle) * this.movement.speed;

                // Oyuncuyu hareket ettir
                const newX = this.sceneObjects.player.position.x + moveX;
                const newZ = this.sceneObjects.player.position.z + moveZ;

                // Sƒ±nƒ±r kontrol√º
                const halfWidth = this.worldMap.width / 2 - 2;
                const halfHeight = this.worldMap.height / 2 - 2;

                // Collision kontrol√º kaldƒ±rƒ±ldƒ± (daƒü ve aƒüa√ß yok)
                let canMove = true;

                if (Math.abs(newX) < halfWidth && Math.abs(newZ) < halfHeight && canMove) {
                    this.sceneObjects.player.position.x = newX;
                    this.sceneObjects.player.position.z = newZ;

                    // Oyuncu pozisyonunu g√ºncelle
                    this.worldMap.playerPosition.x = newX;
                    this.worldMap.playerPosition.z = newZ;

                    // ƒ∞zole bakƒ±≈ü a√ßƒ±sƒ± - oyuncu merkezde kalƒ±r
                    this.updateIsometricView();
                }

                // Tycoon oyununda kaynak toplama yok
            }

            updateIsometricView() {
                if (!this.sceneObjects.player) return;

                // Oyuncuyu her zaman kamera merkezine ta≈üƒ±
                const playerWorldPos = this.sceneObjects.player.position.clone();
                
                // T√ºm sahne objelerini oyuncunun tersi y√∂nde hareket ettir
                const offsetX = -playerWorldPos.x;
                const offsetZ = -playerWorldPos.z;

                // D√ºnya objelerini hareket ettir
                if (this.sceneObjects.world) {
                    this.sceneObjects.world.ground.position.x = offsetX;
                    this.sceneObjects.world.ground.position.z = offsetZ;
                    this.sceneObjects.world.snow.position.x = offsetX;
                    this.sceneObjects.world.snow.position.z = offsetZ;
                }



                // Survival √∂ƒüeleri kaldƒ±rƒ±ldƒ± - sadece tycoon

                // Yollarƒ± hareket ettir
                this.sceneObjects.roads.forEach(road => {
                    road.position.x += offsetX;
                    road.position.z += offsetZ;
                });

                // Evleri hareket ettir
                this.sceneObjects.houses.forEach(house => {
                    house.position.x += offsetX;
                    house.position.z += offsetZ;
                });

                // Tycoon platformlarƒ±nƒ± hareket ettir
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    platform.position.x += offsetX;
                    platform.position.z += offsetZ;
                });
                
                // Tycoon binalarƒ±nƒ± hareket ettir
                this.sceneObjects.tycoonBuildings.forEach(building => {
                    building.position.x += offsetX;
                    building.position.z += offsetZ;
                });

                // Kar sistemini hareket ettir
                if (this.sceneObjects.snowSystem) {
                    this.sceneObjects.snowSystem.position.x += offsetX;
                    this.sceneObjects.snowSystem.position.z += offsetZ;
                }

                // Oyuncuyu merkeze ta≈üƒ±
                this.sceneObjects.player.position.x = 0;
                this.sceneObjects.player.position.z = 0;
            }

            // checkResourceCollection fonksiyonu kaldƒ±rƒ±ldƒ±

            // checkGoldCollection fonksiyonu kaldƒ±rƒ±ldƒ±

            // updateMinimap fonksiyonu kaldƒ±rƒ±ldƒ±

            update3DAnimations() {
                const time = Date.now() * 0.001;

                // Oyuncu y√ºr√ºme animasyonu
                if (this.sceneObjects.player) {
                    const player = this.sceneObjects.player;
                    
                    // Hareket durumunu kontrol et
                    const isMoving = this.movement.keys.w || this.movement.keys.a || 
                                   this.movement.keys.s || this.movement.keys.d ||
                                   this.movement.keys.ArrowUp || this.movement.keys.ArrowLeft ||
                                   this.movement.keys.ArrowDown || this.movement.keys.ArrowRight ||
                                   Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1;
                    
                    if (isMoving) {
                        // Y√ºr√ºme animasyonu - bacaklarƒ± hareket ettir
                        const walkSpeed = 8; // Y√ºr√ºme hƒ±zƒ±
                        const legSwing = Math.sin(time * walkSpeed) * 0.3; // Bacak sallanma miktarƒ±
                        
                        // Sol bacak
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        if (leftLeg) {
                            leftLeg.rotation.x = legSwing;
                        }
                        
                        // Saƒü bacak
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        if (rightLeg) {
                            rightLeg.rotation.x = -legSwing; // Ters y√∂nde hareket
                        }
                        
                        // Kollarƒ± da hafif√ße salla
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftArm) leftArm.rotation.x = -legSwing * 0.5;
                        if (rightArm) rightArm.rotation.x = legSwing * 0.5;
                        
                        // Hafif yukarƒ±-a≈üaƒüƒ± hareket (adƒ±m atma efekti)
                        player.position.y = Math.abs(Math.sin(time * walkSpeed)) * 0.1;
                        
                        // Karakteri hareket y√∂n√ºne g√∂re d√∂nd√ºr
                        let targetRotation = 0;
                        
                        if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                            // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                            targetRotation = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ±
                        } else if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                            // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                            targetRotation = Math.atan2(-15, 15) + Math.PI;
                        } else if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                            // Sol - kameranƒ±n soluna doƒüru
                            targetRotation = Math.atan2(-15, 15) + Math.PI / 2;
                        } else if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                            // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                            targetRotation = Math.atan2(-15, 15) - Math.PI / 2;
                        }
                        
                        // Joystick i√ßin de d√∂nd√ºrme
                        if (Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1) {
                            targetRotation = Math.atan2(-this.movement.joystick.y, this.movement.joystick.x) + Math.atan2(-15, 15);
                        }
                        
                        // Yumu≈üak d√∂nd√ºrme
                        const rotationSpeed = 0.1;
                        const currentRotation = player.rotation.y;
                        const rotationDiff = targetRotation - currentRotation;
                        
                        // En kƒ±sa yolu bul (180 derece √ºzerinden d√∂nmemek i√ßin)
                        let shortestRotation = rotationDiff;
                        if (rotationDiff > Math.PI) shortestRotation -= 2 * Math.PI;
                        if (rotationDiff < -Math.PI) shortestRotation += 2 * Math.PI;
                        
                        player.rotation.y += shortestRotation * rotationSpeed;
                    } else {
                        // Durduƒüunda bacaklarƒ± d√ºzelt
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftLeg) leftLeg.rotation.x = 0;
                        if (rightLeg) rightLeg.rotation.x = 0;
                        if (leftArm) leftArm.rotation.x = 0;
                        if (rightArm) rightArm.rotation.x = 0;
                        
                        // Y pozisyonunu sƒ±fƒ±rla
                        player.position.y = 0;
                    }
                }

                // Kar animasyonu - basitle≈ütirilmi≈ü
                if (this.sceneObjects.snowSystem) {
                    const positions = this.sceneObjects.snowSystem.geometry.attributes.position.array;
                    const velocities = this.sceneObjects.snowSystem.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= velocities[i / 3] * 0.01; // Sabit kar hƒ±zƒ±
                        positions[i] += Math.sin(time + i) * 0.002; // Hafif r√ºzgar
                        
                        if (positions[i + 1] < -5) {
                            positions[i + 1] = 50;
                            positions[i] = (Math.random() - 0.5) * 100;
                            positions[i + 2] = (Math.random() - 0.5) * 100;
                        }
                    }
                    this.sceneObjects.snowSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Survivor animasyonu kaldƒ±rƒ±ldƒ±
            }

            render() {
                // Three.js sahneyi render et - t√ºm objeleri her zaman render et
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // T√ºm objeleri g√∂r√ºn√ºr yap
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
                
                this.renderer.clear();
                this.renderer.render(this.scene, this.camera);
            }


            // resourceDecayLoop fonksiyonu kaldƒ±rƒ±ldƒ±

            updateUI() {
                // Sadece skor g√ºncellemesi - tycoon oyunu
                document.getElementById('scoreDisplay').textContent = `Skor: ${this.gameState.score}`;
            }

            // checkGameOver fonksiyonu kaldƒ±rƒ±ldƒ± - tycoon oyununda game over yok

            gameOver() {
                // Tycoon oyununda game over sistemi yok - sadece fabrika kurma
                console.log("Tycoon oyununda game over yok");
            }

            restartGame() {
                // Oyun durumunu tamamen sƒ±fƒ±rla
                this.gameState = {
                    score: 0,
                    isGameOver: false,
                    gameWon: false,
                    timeLimit: 300, // 5 dakika
                    startTime: Date.now(),
                    targetMoney: 5000,
                    targetIncome: 100,
                    challenges: {
                        breakdownChance: 0.001,
                        lastBreakdown: 0,
                        brokenMachines: [],
                        repairCost: 50
                    }
                };
                
                // Tycoon durumunu sƒ±fƒ±rla
                this.tycoonState.money = 100;
                this.tycoonState.moneyPerSecond = 5;
                this.tycoonState.lastMoneyTime = Date.now();
                this.tycoonState.availableUpgrades.forEach(upgrade => {
                    upgrade.bought = false;
                });
                
                // T√ºm upgrade objelerini kaldƒ±r ve platformlarƒ± sƒ±fƒ±rla
                this.resetFactoryVisuals();

                // UI'ƒ± sƒ±fƒ±rla
                this.updateUI();
                this.updateTycoonUI();
                document.getElementById('gameOverScreen').classList.remove('show');

                // Oyunu yeniden ba≈ülat
                this.startGame();
            }

            resetFactoryVisuals() {
                // T√ºm upgrade objelerini kaldƒ±r
                this.tycoonState.upgradeObjects.forEach(obj => {
                    this.scene.remove(obj);
                });
                this.tycoonState.upgradeObjects = [];
                
                // Platform renklerini sƒ±fƒ±rla
                this.updatePlatformColors();
                
                // Etiketleri yeniden olu≈ütur
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const upgrade = platform.userData.upgrade;
                    if (!upgrade.bought) {
                        this.createUpgradeLabel(upgrade);
                    }
                });
            }
        }

        // Oyunu ba≈ülat
        window.addEventListener('load', () => {
            new ColdHorizon3D();
        });

        // Farcade SDK event listeners
        window.addEventListener('play_again', () => {
            location.reload();
        });

        window.addEventListener('toggle_mute', () => {
            // Ses kontrol√º (≈üu anda ses yok)
            console.log('Ses a√ßƒ±k/kapalƒ±');
        });
    </script>
</body>
</html>
