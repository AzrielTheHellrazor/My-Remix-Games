<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cold Horizon 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            background: linear-gradient(180deg, #0a1929 0%, #1e3a5f 50%, #2d5aa0 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            height: 750px;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            border: 2px solid #334155;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }

        #gameCanvas {
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .top-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .score {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            color: #fbbf24;
            border: 2px solid #f59e0b;
        }

        .resources {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 15px;
            min-width: 120px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            font-size: 16px;
        }

        .resource-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .heat-fill { background: linear-gradient(90deg, #f97316 0%, #ea580c 100%); }
        .food-fill { background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%); }
        .shelter-fill { background: linear-gradient(90deg, #3b82f6 0%, #2563eb 100%); }

        /* Tycoon UI */
        .tycoon-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            min-width: 200px;
            color: white;
            font-weight: bold;
        }

        .money-display {
            font-size: 18px;
            color: #10b981;
            margin-bottom: 5px;
        }

        .income-display {
            font-size: 14px;
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .upgrade-info {
            font-size: 12px;
            color: #94a3b8;
            text-align: center;
            border-top: 1px solid #374151;
            padding-top: 8px;
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .game-over-screen.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .game-over-title {
            font-size: 48px;
            font-weight: bold;
            color: #60a5fa;
            text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
        }

        .final-score {
            font-size: 24px;
            color: #fbbf24;
        }

        .restart-btn {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s ease;
            pointer-events: all;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }


        /* Mobil Joystick */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .mobile-controls.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .joystick {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #3b82f6;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: 2px solid #ffffff;
            position: absolute;
            cursor: grab;
            transition: transform 0.1s ease;
        }

        .joystick-knob:active {
            cursor: grabbing;
        }

        /* Klavye kontrolleri g√∂stergesi */
        .keyboard-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Minimap */
        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #3b82f6;
            border-radius: 10px;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }


        @media (max-width: 520px) {
            .game-container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Three.js CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        
        <div class="ui-overlay">
            <!-- Tycoon UI -->
            <div class="tycoon-ui" id="tycoonUI">
                <div class="money-display" id="moneyDisplay">üí∞ $100</div>
                <div class="income-display" id="incomeDisplay">üìà +$5/sn</div>
                <div class="upgrade-info">
                    üí° Daire platformlara √ßƒ±k ve upgrade satƒ±n al!
                </div>
            </div>

            <div class="top-ui">
                <div class="score" id="scoreDisplay">Skor: 0</div>
                <div class="resources">
                    <div class="resource">
                        <div class="resource-icon">üî•</div>
                        <div class="resource-bar">
                            <div class="resource-fill heat-fill" id="heatBar" style="width: 100%"></div>
                        </div>
                    </div>
                    <div class="resource">
                        <div class="resource-icon">üçñ</div>
                        <div class="resource-bar">
                            <div class="resource-fill food-fill" id="foodBar" style="width: 100%"></div>
                        </div>
                    </div>
                    <div class="resource">
                        <div class="resource-icon">üè†</div>
                        <div class="resource-bar">
                            <div class="resource-fill shelter-fill" id="shelterBar" style="width: 100%"></div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Mobil Joystick -->
            <div class="mobile-controls" id="mobileControls">
                <div class="joystick">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>

            <!-- Klavye Kontrol√º G√∂stergesi -->
            <div class="keyboard-hint" id="keyboardHint">
                WASD / ‚Üê‚Üí‚Üë‚Üì Hareket
            </div>

            <!-- Minimap -->
            <div class="minimap" id="minimap">
                <canvas class="minimap-canvas" id="minimapCanvas"></canvas>
            </div>

            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over-title">DONDU!</div>
                <div class="final-score" id="finalScore">Final Skor: 0</div>
                <button class="restart-btn" id="restartBtn">Yeniden Ba≈üla</button>
            </div>
        </div>
    </div>

    <script>
        // Farcade SDK Mock (ger√ßek SDK y√ºklendiƒüinde deƒüi≈ütirilecek)
        const Farcade = {
            ready: () => console.log('Farcade ready'),
            gameOver: (data) => console.log('Game over:', data),
            hapticFeedback: () => {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        };

        class ColdHorizon3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                
                // Canvas boyutlarƒ±nƒ± ayarla
                this.setupCanvas();
                
                // Three.js sahne olu≈ütur
                this.initThreeJS();
                
                // Oyun durumu - sadece tycoon i√ßin gerekli olanlar
                this.gameState = {
                    score: 0,
                    isGameOver: false
                };

                // Tycoon sistemi
                this.tycoonState = {
                    money: 100, // Ba≈ülangƒ±√ß parasƒ±
                    moneyPerSecond: 5, // Saniyede kazanc
                    lastMoneyTime: Date.now(),
                    upgrades: [], // Satƒ±n alƒ±nan upgrade'ler
                    availableUpgrades: [
                        {
                            id: 'raw_material',
                            name: 'Hammadde Deposu',
                            price: 100,
                            position: { x: -4, z: 0 },
                            bought: false,
                            description: '+$5/sn',
                            step: 1,
                            requires: null,
                            info: 'Fabrika i√ßin hammadde tedarik eder'
                        },
                        {
                            id: 'conveyor_input',
                            name: 'Giri≈ü Konveyor√º',
                            price: 200,
                            position: { x: -2, z: 0 },
                            bought: false,
                            description: '+$3/sn',
                            step: 2,
                            requires: 'raw_material',
                            info: 'Hammaddeyi i≈üleme alanƒ±na ta≈üƒ±r'
                        },
                        {
                            id: 'processing_machine',
                            name: 'ƒ∞≈üleme Makinesi',
                            price: 400,
                            position: { x: 0, z: 0 },
                            bought: false,
                            description: '+$10/sn',
                            step: 3,
                            requires: 'conveyor_input',
                            info: 'Hammaddeyi i≈üleyip √ºr√ºne √ßevirir'
                        },
                        {
                            id: 'quality_control',
                            name: 'Kalite Kontrol',
                            price: 600,
                            position: { x: 2, z: 0 },
                            bought: false,
                            description: '+$8/sn',
                            step: 4,
                            requires: 'processing_machine',
                            info: '√úr√ºnlerin kalitesini kontrol eder'
                        },
                        {
                            id: 'packaging',
                            name: 'Paketleme √únitesi',
                            price: 1000,
                            position: { x: 4, z: 0 },
                            bought: false,
                            description: '+$15/sn',
                            step: 5,
                            requires: 'quality_control',
                            info: '√úr√ºnleri paketleyip satƒ±≈üa hazƒ±rlar'
                        },
                        {
                            id: 'shipping',
                            name: 'Kargo √únitesi',
                            price: 1500,
                            position: { x: 6, z: 0 },
                            bought: false,
                            description: '+$25/sn',
                            step: 6,
                            requires: 'packaging',
                            info: 'Paketlenen √ºr√ºnleri m√º≈üterilere g√∂nderir'
                        }
                    ],
                    upgradePlatforms: [],
                    upgradeObjects: []
                };

                // 3D objeler
                this.sceneObjects = {
                    shelter: null,
                    fire: null,
                    survivors: [],
                    snowSystem: null,
                    player: null,
                    roads: [],
                    houses: [],
                    factoryFloor: null,
                    world: null,
                    tycoonPlatforms: [],
                    tycoonBuildings: []
                };

                // Hareket sistemi
                this.movement = {
                    keys: {
                        w: false, a: false, s: false, d: false,
                        ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
                    },
                    speed: 0.3,
                    joystick: { x: 0, y: 0 }
                };

                // Harita sistemi
                this.worldMap = {
                    width: 100,
                    height: 100,
                    playerPosition: { x: 0, y: 0, z: 0 }
                };

                // Minimap
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.setupMinimap();
                

                // Event listeners
                this.setupEventListeners();
                
                // 3D sahneyi olu≈ütur
                this.create3DScene();
                
                // Oyunu ba≈ülat
                this.startGame();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                this.width = rect.width;
                this.height = rect.height;
            }

            initThreeJS() {
                // Sahne olu≈ütur
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0f172a, 50, 200);

                // Kamera olu≈ütur (perspektif kamera)
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    this.width / this.height, 
                    0.1, 
                    1000
                );
                // Kamerayƒ± Y ekseni sabit kalacak ≈üekilde ters y√∂nde d√∂nd√ºr (yakƒ±nla≈ütƒ±rƒ±lmƒ±≈ü)
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // Kamera frustum ayarlarƒ±
                this.camera.far = 1000;
                this.camera.near = 0.1;
                
                // Kamerayƒ± tamamen sabitle
                this.camera.position.x = -15;
                this.camera.position.y = 20;
                this.camera.position.z = 15;

                // Renderer olu≈ütur
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: false,
                    logarithmicDepthBuffer: false
                });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = false; // G√∂lgeleri kapat
                this.renderer.setClearColor(0x0f172a, 1);
                
                // Render optimizasyonlarƒ±nƒ± kapat
                this.renderer.sortObjects = false;
                this.renderer.autoClear = true;
                
                // Frustum culling'i tamamen kapat
                this.renderer.setClearColor(0x0f172a, 1);
                this.scene.autoUpdate = true;

                // I≈üƒ±klandƒ±rma
                this.setupLighting();

                // Kamera kontrolleri
                this.setupCameraControls();
            }

            setupLighting() {
                // Ambient ƒ±≈üƒ±k (genel aydƒ±nlatma)
                const ambientLight = new THREE.AmbientLight(0x334155, 0.3);
                this.scene.add(ambientLight);

                // Direkt ƒ±≈üƒ±k (g√ºne≈ü)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Ate≈ü ƒ±≈üƒ±ƒüƒ± (point light)
                this.fireLight = new THREE.PointLight(0xf97316, 2, 15);
                this.fireLight.position.set(0, 2, 0);
                this.fireLight.castShadow = true;
                this.scene.add(this.fireLight);
            }

            setupCameraControls() {
                // Kamera tamamen sabit - hi√ßbir kontrol yok
            }

            setupEventListeners() {
                // Klavye kontrolleri
                document.addEventListener('keydown', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = true;
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = false;
                        e.preventDefault();
                    }
                });

                // Dokunmatik kontroller (artƒ±k sadece joystick i√ßin)

                // Yeniden ba≈ülat
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                    Farcade.hapticFeedback();
                });

                // Mobil joystick
                this.setupJoystick();

                // Mobil kontrolleri g√∂ster/gizle
                this.detectMobile();

                // Resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
            }

            detectMobile() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const mobileControls = document.getElementById('mobileControls');
                const keyboardHint = document.getElementById('keyboardHint');
                
                if (isMobile) {
                    mobileControls.classList.add('show');
                    keyboardHint.style.display = 'none';
                } else {
                    mobileControls.classList.remove('show');
                    keyboardHint.style.display = 'block';
                }
            }

            setupJoystick() {
                const joystick = document.getElementById('joystickKnob');
                let isDragging = false;
                let startPos = { x: 0, y: 0 };

                joystick.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                joystick.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    
                    const touch = e.touches[0];
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                    
                    e.preventDefault();
                });

                joystick.addEventListener('touchend', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });

                // Mouse desteƒüi (masa√ºst√º test i√ßin)
                joystick.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = e.clientX - centerX;
                    const deltaY = e.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });
            }

            setupMinimap() {
                this.minimapCanvas.width = 150;
                this.minimapCanvas.height = 150;
            }

            create3DScene() {
                this.createWorld();
                this.createPlayer();
                this.createTycoonPlatforms();
                this.createSnowSystem();
                
                // T√ºm objeleri ba≈ütan render et
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
            }

            createWorld() {
                // T√ºm harita ba≈ütan y√ºklensin - b√ºy√ºk d√ºnya zemini
                const groundGeometry = new THREE.PlaneGeometry(this.worldMap.width, this.worldMap.height);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1e293b,
                    transparent: false,
                    opacity: 1.0
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                ground.frustumCulled = false; // T√ºm harita her zaman g√∂r√ºn√ºr
                ground.visible = true;
                this.scene.add(ground);

                // T√ºm kar zemini y√ºklensin
                const snowGeometry = new THREE.PlaneGeometry(this.worldMap.width + 20, this.worldMap.height + 20);
                const snowMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf8fafc,
                    transparent: true,
                    opacity: 0.6
                });
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                snow.rotation.x = -Math.PI / 2;
                snow.position.y = 0.01;
                snow.frustumCulled = false; // T√ºm kar zemini her zaman g√∂r√ºn√ºr
                snow.visible = true;
                this.scene.add(snow);

                // D√ºnya sƒ±nƒ±rlarƒ± (g√∂r√ºnmez duvarlar)
                this.createWorldBounds();

                this.sceneObjects.world = { ground, snow };
            }

            createWorldBounds() {
                // D√ºnya sƒ±nƒ±rlarƒ± i√ßin g√∂r√ºnmez duvarlar
                const bounds = [
                    { pos: [0, 25, this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // Arka
                    { pos: [0, 25, -this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // √ñn
                    { pos: [this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }, // Saƒü
                    { pos: [-this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }  // Sol
                ];

                bounds.forEach(bound => {
                    const geometry = new THREE.BoxGeometry(bound.size[0], bound.size[1], bound.size[2]);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0 
                    });
                    const wall = new THREE.Mesh(geometry, material);
                    wall.position.set(bound.pos[0], bound.pos[1], bound.pos[2]);
                    wall.userData = { isBoundary: true };
                    wall.frustumCulled = false; // Frustum culling'i devre dƒ±≈üƒ± bƒ±rak
                    this.scene.add(wall);
                });
            }

            createTycoonPlatforms() {
                console.log("Tycoon platformlarƒ± olu≈üturuluyor...");
                
                this.tycoonState.availableUpgrades.forEach(upgrade => {
                    // Platform olu≈ütur
                    const platformGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.2, 16);
                    let platformColor = 0xff6b35; // Turuncu - satƒ±n alƒ±nabilir
                    
                    if (upgrade.bought) {
                        platformColor = 0x10b981; // Ye≈üil - satƒ±n alƒ±nmƒ±≈ü
                    } else if (upgrade.requires && !this.isUpgradeBought(upgrade.requires)) {
                        platformColor = 0x6b7280; // Gri - hen√ºz satƒ±n alƒ±namaz
                    }
                    
                    const platformMaterial = new THREE.MeshLambertMaterial({ 
                        color: platformColor,
                        transparent: false,
                        opacity: 0.8
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    
                    platform.position.set(upgrade.position.x, 0.1, upgrade.position.z);
                    platform.userData = { 
                        type: 'upgradePlatform',
                        upgradeId: upgrade.id,
                        upgrade: upgrade
                    };
                    
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    platform.frustumCulled = false;
                    
                    this.scene.add(platform);
                    this.sceneObjects.tycoonPlatforms.push(platform);
                    this.tycoonState.upgradePlatforms.push(platform);
                    
                    // Platform √ºzerinde bilgi etiketi olu≈ütur
                    if (!upgrade.bought) {
                        this.createUpgradeLabel(upgrade);
                    }
                    
                    console.log(`Platform olu≈üturuldu: ${upgrade.name} - $${upgrade.price}`);
                });
                
                console.log(`Toplam ${this.tycoonState.upgradePlatforms.length} tycoon platformƒ± olu≈üturuldu`);
            }

            createUpgradeLabel(upgrade) {
                // Upgrade bilgi etiketi olu≈ütur
                const labelGeometry = new THREE.BoxGeometry(3, 0.8, 0.1);
                let labelColor = 0x1f2937; // Koyu gri - normal
                
                if (upgrade.requires && !this.isUpgradeBought(upgrade.requires)) {
                    labelColor = 0x7f1d1d; // Koyu kƒ±rmƒ±zƒ± - kilitli
                }
                
                const labelMaterial = new THREE.MeshLambertMaterial({ 
                    color: labelColor,
                    transparent: true,
                    opacity: 0.9
                });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                
                label.position.set(upgrade.position.x, 2, upgrade.position.z + 1);
                label.userData = { 
                    type: 'upgradeLabel',
                    upgradeId: upgrade.id,
                    upgrade: upgrade
                };
                
                this.scene.add(label);
                this.sceneObjects.tycoonBuildings.push(label);
                
                // Adƒ±m numarasƒ± g√∂stergesi ekle
                this.createStepIndicator(upgrade);
            }

            createStepIndicator(upgrade) {
                // Adƒ±m numarasƒ± i√ßin k√º√ß√ºk daire
                const stepGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                const stepMaterial = new THREE.MeshLambertMaterial({ 
                    color: upgrade.bought ? 0x10b981 : 0xfbbf24,
                    emissive: upgrade.bought ? 0x003300 : 0x332200
                });
                const stepIndicator = new THREE.Mesh(stepGeometry, stepMaterial);
                
                stepIndicator.position.set(upgrade.position.x - 1, 0.3, upgrade.position.z - 1);
                stepIndicator.userData = { 
                    type: 'stepIndicator',
                    step: upgrade.step,
                    upgradeId: upgrade.id
                };
                
                this.scene.add(stepIndicator);
                this.sceneObjects.tycoonBuildings.push(stepIndicator);
            }

            isUpgradeBought(upgradeId) {
                const upgrade = this.tycoonState.availableUpgrades.find(u => u.id === upgradeId);
                return upgrade ? upgrade.bought : false;
            }

            createPlayer() {
                // ƒ∞nsan ≈üeklinde oyuncu karakteri olu≈ütur
                const player = new THREE.Group();
                
                // V√ºcut (ana g√∂vde) - daha b√ºy√ºk
                const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.4, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3b82f6 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                body.castShadow = true;
                player.add(body);

                // Kafa - daha b√ºy√ºk
                const headGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.0;
                head.castShadow = true;
                player.add(head);

                // Sa√ß - daha b√ºy√ºk
                const hairGeometry = new THREE.SphereGeometry(0.54, 8, 6);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 3.1;
                hair.scale.y = 0.7;
                player.add(hair);

                // Sol kol - daha b√ºy√ºk
                const leftArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
                leftArm.position.set(-0.8, 1.6, 0);
                leftArm.rotation.z = 0.3;
                leftArm.castShadow = true;
                player.add(leftArm);

                // Saƒü kol - daha b√ºy√ºk
                const rightArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
                rightArm.position.set(0.8, 1.6, 0);
                rightArm.rotation.z = -0.3;
                rightArm.castShadow = true;
                player.add(rightArm);

                // Sol bacak - daha b√ºy√ºk
                const leftLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                const leftLeg = new THREE.Mesh(leftLegGeometry, legMaterial);
                leftLeg.position.set(-0.3, -1.0, 0);
                leftLeg.castShadow = true;
                player.add(leftLeg);

                // Saƒü bacak - daha b√ºy√ºk
                const rightLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const rightLeg = new THREE.Mesh(rightLegGeometry, legMaterial);
                rightLeg.position.set(0.3, -1.0, 0);
                rightLeg.castShadow = true;
                player.add(rightLeg);

                // Ayaklar - daha b√ºy√ºk
                const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.8);
                const footMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                
                const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                leftFoot.position.set(-0.3, -2.1, 0.2);
                leftFoot.castShadow = true;
                player.add(leftFoot);

                const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                rightFoot.position.set(0.3, -2.1, 0.2);
                rightFoot.castShadow = true;
                player.add(rightFoot);

                // Oyuncuyu sahneye ekle - ba≈ülangƒ±√ß pozisyonu 0,0,0
                player.position.set(0, 0, 0);
                this.scene.add(player);

                this.sceneObjects.player = player;
            }


            createResourcePoints() {

                // Yiyecek noktalarƒ±
                const foodCount = 15;
                for (let i = 0; i < foodCount; i++) {
                    const foodGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                    const foodMaterial = new THREE.MeshLambertMaterial({ color: 0xfbbf24 });
                    const food = new THREE.Mesh(foodGeometry, foodMaterial);
                    
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * (this.worldMap.width - 20);
                        z = (Math.random() - 0.5) * (this.worldMap.height - 20);
                    } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                    
                    food.position.set(x, 0.25, z);
                    food.castShadow = true;
                    food.frustumCulled = false; // Frustum culling'i devre dƒ±≈üƒ± bƒ±rak
                    food.userData = { type: 'food', resource: 'food', amount: 50 };
                    this.scene.add(food);
                    
                    this.sceneObjects.resourcePoints.push(food);
                }
            }

            createRoads() {
                // Yol sistemi kaldƒ±rƒ±ldƒ±
                console.log("Yollar kaldƒ±rƒ±ldƒ±");
            }

            createSimpleRoad(x, y, z, width, length, material) {
                // Yol olu≈üturma fonksiyonu kaldƒ±rƒ±ldƒ±
                return null;
            }

            createFactoryFloor() {
                // Fabrika zemini kaldƒ±rƒ±ldƒ±
                console.log("Fabrika zemini kaldƒ±rƒ±ldƒ±");
                this.sceneObjects.factoryFloor = null;
            }

            createHouses() {
                // Ev sistemi kaldƒ±rƒ±ldƒ±
                console.log("Evler kaldƒ±rƒ±ldƒ±");
            }

            isPositionOnRoad(x, z, roadSpacing) {
                // Yol kontrol√º kaldƒ±rƒ±ldƒ± - artƒ±k yol yok
                return false;
            }

            createHouse(x, z, material) {
                // Ev olu≈üturma fonksiyonu kaldƒ±rƒ±ldƒ±
                return null;
            }

            createGoldCoins() {
                // Altƒ±n paralar olu≈ütur
                const goldCount = 25;
                for (let i = 0; i < goldCount; i++) {
                    const goldGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
                    const goldMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffd700, // Altƒ±n rengi
                        emissive: 0x332200 // Hafif parƒ±ltƒ±
                    });
                    const goldCoin = new THREE.Mesh(goldGeometry, goldMaterial);
                    
                    // Rastgele pozisyon (barƒ±nak √ßevresinde deƒüil)
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * (this.worldMap.width - 20);
                        z = (Math.random() - 0.5) * (this.worldMap.height - 20);
                    } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                    
                    goldCoin.position.set(x, 0.05, z);
                    goldCoin.castShadow = true;
                    goldCoin.frustumCulled = false;
                    goldCoin.userData = { 
                        type: 'gold', 
                        value: Math.floor(Math.random() * 50) + 10, // 10-60 puan
                        collected: false
                    };
                    this.scene.add(goldCoin);
                    
                    this.sceneObjects.goldCoins.push(goldCoin);
                }
            }

            createShelter() {
                // Barƒ±nak duvarlarƒ±
                const wallGeometry = new THREE.BoxGeometry(8, 4, 6);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x475569 });
                
                // Arka duvar
                const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
                backWall.position.set(0, 2, -3);
                backWall.castShadow = true;
                this.scene.add(backWall);

                // Sol duvar
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                leftWall.position.set(-4, 2, 0);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.castShadow = true;
                this.scene.add(leftWall);

                // Saƒü duvar
                const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
                rightWall.position.set(4, 2, 0);
                rightWall.rotation.y = Math.PI / 2;
                rightWall.castShadow = true;
                this.scene.add(rightWall);

                // √áatƒ±
                const roofGeometry = new THREE.ConeGeometry(6, 3, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x64748b });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 5, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                this.scene.add(roof);

                this.sceneObjects.shelter = { backWall, leftWall, rightWall, roof };
            }


            createFire() {
                // Ate≈ü geometrisi
                const fireGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                const fireMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf97316,
                    emissive: 0xf97316,
                    emissiveIntensity: 0.5
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set(0, 1, 0);
                fire.castShadow = true;
                this.scene.add(fire);

                // Ate≈ü partik√ºlleri
                const particleCount = 50;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 2;
                    positions[i * 3 + 1] = Math.random() * 3;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

                    const color = new THREE.Color();
                    color.setHSL(0.1, 1, Math.random() * 0.5 + 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: false,
                    opacity: 0.8
                });

                const fireParticles = new THREE.Points(particles, particleMaterial);
                fireParticles.position.set(0, 1, 0);
                this.scene.add(fireParticles);

                this.sceneObjects.fire = { fire, particles: fireParticles };
            }

            createSurvivors() {
                // Hayatta kalan karakterleri olu≈ütur
                for (let i = 0; i < this.gameState.survivors; i++) {
                    this.addSurvivor(i);
                }
            }

            addSurvivor(index) {
                const survivorGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
                const survivorMaterial = new THREE.MeshLambertMaterial({ color: 0xfbbf24 });
                const survivor = new THREE.Mesh(survivorGeometry, survivorMaterial);
                
                const angle = (index / this.gameState.survivors) * Math.PI * 2;
                survivor.position.set(
                    Math.cos(angle) * 6,
                    0.75,
                    Math.sin(angle) * 6
                );
                survivor.castShadow = true;
                this.scene.add(survivor);
                
                this.sceneObjects.survivors.push(survivor);
            }

            createSnowSystem() {
                // Kar sistemi - ba≈ütan render et, t√ºm harita alanƒ±na
                const snowCount = 2000; // Daha fazla kar par√ßacƒ±ƒüƒ±
                const snowGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(snowCount * 3);
                const velocities = new Float32Array(snowCount);

                // T√ºm harita alanƒ±na kar par√ßacƒ±klarƒ± yerle≈ütir
                for (let i = 0; i < snowCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * (this.worldMap.width + 50);
                    positions[i * 3 + 1] = Math.random() * 80 + 20; // Daha y√ºksekten ba≈üla
                    positions[i * 3 + 2] = (Math.random() - 0.5) * (this.worldMap.height + 50);
                    velocities[i] = Math.random() * 2 + 1;
                }

                snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

                const snowMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.9
                });

                const snowSystem = new THREE.Points(snowGeometry, snowMaterial);
                snowSystem.frustumCulled = false; // Her zaman render et
                snowSystem.visible = true;
                this.scene.add(snowSystem);
                
                this.sceneObjects.snowSystem = snowSystem;
            }

            startGame() {
                this.gameLoop();
                this.resourceDecayLoop();
                this.updateTycoonUI(); // Tycoon UI'yi ba≈ülat
                this.updatePlatformColors(); // Platform renklerini g√ºncelle
                Farcade.ready();
            }

            gameLoop() {
                if (this.gameState.isGameOver) return;

                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                // Tycoon sistemini g√ºncelle
                this.updateTycoonSystem();
                
                // Fƒ±rtƒ±na yoƒüunluƒüunu artƒ±r
                const now = Date.now();
                if (now - this.gameState.lastStormIncrease > 30000) { // 30 saniye
                    this.gameState.stormIntensity += 0.2;
                    this.gameState.lastStormIncrease = now;
                }

                // Oyuncu hareketi
                this.updatePlayerMovement();

                // 3D animasyonlarƒ± g√ºncelle
                this.update3DAnimations();

                // Minimap g√ºncelle
                this.updateMinimap();

                // Oyun bitti mi kontrol et
                this.checkGameOver();
            }

            updateTycoonSystem() {
                const now = Date.now();
                const timeSinceLastMoney = now - this.tycoonState.lastMoneyTime;
                
                // Her saniyede para √ºret
                if (timeSinceLastMoney >= 1000) {
                    this.tycoonState.money += this.tycoonState.moneyPerSecond;
                    this.tycoonState.lastMoneyTime = now;
                    this.updateTycoonUI();
                }
                
                // Platform √ßarpƒ±≈üma kontrol√º
                this.checkPlatformCollisions();
            }

            updateTycoonUI() {
                document.getElementById('moneyDisplay').textContent = `üí∞ $${this.tycoonState.money.toLocaleString()}`;
                document.getElementById('incomeDisplay').textContent = `üìà +$${this.tycoonState.moneyPerSecond}/sn`;
                
                // Fabrika ilerleme durumunu g√∂ster
                const completedSteps = this.tycoonState.availableUpgrades.filter(u => u.bought).length;
                const totalSteps = this.tycoonState.availableUpgrades.length;
                const nextUpgrade = this.getNextAvailableUpgrade();
                
                let infoText = `üè≠ Fabrika: ${completedSteps}/${totalSteps} Tamamlandƒ±`;
                if (nextUpgrade) {
                    infoText += `<br>üîÑ Sonraki: ${nextUpgrade.name} ($${nextUpgrade.price})`;
                    if (nextUpgrade.requires && !this.isUpgradeBought(nextUpgrade.requires)) {
                        const requiredUpgrade = this.tycoonState.availableUpgrades.find(u => u.id === nextUpgrade.requires);
                        infoText += `<br>‚ö†Ô∏è √ñnce: ${requiredUpgrade.name}`;
                    }
                }
                
                document.querySelector('.upgrade-info').innerHTML = infoText;
            }

            getNextAvailableUpgrade() {
                return this.tycoonState.availableUpgrades
                    .filter(u => !u.bought)
                    .sort((a, b) => a.step - b.step)[0];
            }

            checkPlatformCollisions() {
                if (!this.sceneObjects.player) return;
                
                const playerPos = this.sceneObjects.player.position;
                const collisionRange = 1.5;
                
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const platformPos = platform.position;
                    
                    // Oyuncu merkezde olduƒüu i√ßin platform pozisyonuna g√∂re mesafe hesapla
                    const distance = Math.sqrt(
                        Math.pow(platformPos.x, 2) + 
                        Math.pow(platformPos.z, 2)
                    );
                    
                    if (distance < collisionRange) {
                        const upgrade = platform.userData.upgrade;
                        
                        if (!upgrade.bought && this.canPurchaseUpgrade(upgrade)) {
                            this.purchaseUpgrade(upgrade, platform);
                        }
                    }
                });
            }

            canPurchaseUpgrade(upgrade) {
                // Para kontrol√º
                if (this.tycoonState.money < upgrade.price) {
                    return false;
                }
                
                // √ñn ko≈üul kontrol√º - sƒ±ralƒ± upgrade sistemi
                if (upgrade.requires) {
                    const requiredUpgrade = this.tycoonState.availableUpgrades.find(u => u.id === upgrade.requires);
                    if (!requiredUpgrade || !requiredUpgrade.bought) {
                        console.log(`‚ö†Ô∏è √ñnce ${requiredUpgrade ? requiredUpgrade.name : upgrade.requires} satƒ±n almalƒ±sƒ±nƒ±z!`);
                        return false;
                    }
                }
                
                return true;
            }

            purchaseUpgrade(upgrade, platform) {
                console.log(`Upgrade satƒ±n alƒ±nƒ±yor: ${upgrade.name} - $${upgrade.price}`);
                
                // Parayƒ± d√º≈ü
                this.tycoonState.money -= upgrade.price;
                
                // Upgrade'ƒ± satƒ±n alƒ±nmƒ±≈ü olarak i≈üaretle
                upgrade.bought = true;
                
                // Geliri artƒ±r
                const incomeIncrease = parseInt(upgrade.description.match(/\d+/)[0]);
                this.tycoonState.moneyPerSecond += incomeIncrease;
                
                // Platform rengini deƒüi≈ütir
                platform.material.color.setHex(0x10b981); // Ye≈üil
                
                // Upgrade objesi olu≈ütur
                this.createUpgradeObject(upgrade);
                
                // Upgrade etiketini kaldƒ±r
                this.removeUpgradeLabel(upgrade.id);
                
                // Sonraki upgrade'lerin rengini g√ºncelle
                this.updatePlatformColors();
                
                // UI g√ºncelle
                this.updateTycoonUI();
                
                // Haptic feedback
                if (typeof Farcade !== 'undefined' && Farcade.hapticFeedback) {
                    Farcade.hapticFeedback();
                }
                
                console.log(`‚úÖ ${upgrade.name} satƒ±n alƒ±ndƒ±! Yeni gelir: +$${this.tycoonState.moneyPerSecond}/sn`);
            }

            createUpgradeObject(upgrade) {
                let geometry, material, mesh;
                
                switch(upgrade.id) {
                    case 'raw_material':
                        // Hammadde deposu - b√ºy√ºk dikd√∂rtgen depo
                        geometry = new THREE.BoxGeometry(2, 2.5, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Kahverengi
                        break;
                    case 'conveyor_input':
                        // Konveyor bant - uzun ve d√º≈ü√ºk
                        geometry = new THREE.BoxGeometry(2.5, 0.3, 0.8);
                        material = new THREE.MeshLambertMaterial({ color: 0x2F4F4F }); // Koyu gri
                        break;
                    case 'processing_machine':
                        // ƒ∞≈üleme makinesi - karma≈üƒ±k makine g√∂r√ºn√ºm√º
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x4682B4 }); // √áelik mavisi
                        break;
                    case 'quality_control':
                        // Kalite kontrol - y√ºksek ince makine
                        geometry = new THREE.BoxGeometry(1.5, 2.5, 1.5);
                        material = new THREE.MeshLambertMaterial({ color: 0x32CD32 }); // Ye≈üil
                        break;
                    case 'packaging':
                        // Paketleme √ºnitesi - orta boy kare
                        geometry = new THREE.BoxGeometry(2.2, 1.8, 2.2);
                        material = new THREE.MeshLambertMaterial({ color: 0xFF8C00 }); // Turuncu
                        break;
                    case 'shipping':
                        // Kargo √ºnitesi - b√ºy√ºk y√ºkleme rampasƒ±
                        geometry = new THREE.BoxGeometry(3, 2.5, 2.5);
                        material = new THREE.MeshLambertMaterial({ color: 0xDC143C }); // Kƒ±rmƒ±zƒ±
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                }
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(upgrade.position.x, geometry.parameters ? geometry.parameters.height/2 : 1, upgrade.position.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: 'upgradeObject', upgradeId: upgrade.id };
                
                this.scene.add(mesh);
                this.sceneObjects.tycoonBuildings.push(mesh);
                this.tycoonState.upgradeObjects.push(mesh);
                
                // Fabrika makineleri i√ßin ek detaylar ekle
                this.addMachineDetails(upgrade, mesh);
            }

            addMachineDetails(upgrade, mainMesh) {
                const position = mainMesh.position;
                
                switch(upgrade.id) {
                    case 'processing_machine':
                        // Makine √ºst√ºnde boru sistemi
                        const pipe = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, 1, 8),
                            new THREE.MeshLambertMaterial({ color: 0x708090 })
                        );
                        pipe.position.set(position.x, position.y + 1.5, position.z);
                        pipe.castShadow = true;
                        this.scene.add(pipe);
                        this.sceneObjects.tycoonBuildings.push(pipe);
                        break;
                        
                    case 'quality_control':
                        // Kalite kontrol i√ßin tarayƒ±cƒ± ƒ±≈üƒ±k
                        const scanner = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.3, 1.8),
                            new THREE.MeshLambertMaterial({ color: 0x00FF00, emissive: 0x003300 })
                        );
                        scanner.position.set(position.x, position.y + 0.8, position.z);
                        scanner.castShadow = true;
                        this.scene.add(scanner);
                        this.sceneObjects.tycoonBuildings.push(scanner);
                        break;
                        
                    case 'shipping':
                        // Kargo i√ßin y√ºkleme rampasƒ±
                        const ramp = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 0.2, 3),
                            new THREE.MeshLambertMaterial({ color: 0x696969 })
                        );
                        ramp.position.set(position.x + 1.5, position.y - 1, position.z);
                        ramp.rotation.z = -0.3;
                        ramp.castShadow = true;
                        this.scene.add(ramp);
                        this.sceneObjects.tycoonBuildings.push(ramp);
                        break;
                }
            }

            removeUpgradeLabel(upgradeId) {
                // Upgrade etiketini ve step indicator'ƒ± bul ve kaldƒ±r
                for (let i = this.sceneObjects.tycoonBuildings.length - 1; i >= 0; i--) {
                    const building = this.sceneObjects.tycoonBuildings[i];
                    if ((building.userData.type === 'upgradeLabel' || building.userData.type === 'stepIndicator') && 
                        building.userData.upgradeId === upgradeId) {
                        this.scene.remove(building);
                        this.sceneObjects.tycoonBuildings.splice(i, 1);
                    }
                }
            }

            updatePlatformColors() {
                // T√ºm platformlarƒ±n renklerini g√ºncelle
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const upgrade = platform.userData.upgrade;
                    let newColor = 0xff6b35; // Turuncu - satƒ±n alƒ±nabilir
                    
                    if (upgrade.bought) {
                        newColor = 0x10b981; // Ye≈üil - satƒ±n alƒ±nmƒ±≈ü
                    } else if (upgrade.requires && !this.isUpgradeBought(upgrade.requires)) {
                        newColor = 0x6b7280; // Gri - hen√ºz satƒ±n alƒ±namaz
                    }
                    
                    platform.material.color.setHex(newColor);
                });
            }

            updatePlayerMovement() {
                if (!this.sceneObjects.player) return;

                let moveX = 0;
                let moveZ = 0;

                // Kamera a√ßƒ±sƒ±na g√∂re hareket eksenlerini ayarla
                // Kamera (-15, 20, 15) pozisyonunda, merkeze bakƒ±yor
                // Bu y√ºzden hareket eksenlerini kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re ayarlayalƒ±m
                const cameraAngle = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ± (g√ºncellenmi≈ü)

                // Klavye kontrolleri - kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re (d√ºzeltilmi≈ü y√∂nler)
                if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                    // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                    moveX -= Math.sin(cameraAngle) * this.movement.speed;
                    moveZ -= Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                    // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                    moveX += Math.sin(cameraAngle) * this.movement.speed;
                    moveZ += Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                    // Sol - kameranƒ±n soluna doƒüru
                    moveX -= Math.cos(cameraAngle) * this.movement.speed;
                    moveZ += Math.sin(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                    // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                    moveX += Math.cos(cameraAngle) * this.movement.speed;
                    moveZ -= Math.sin(cameraAngle) * this.movement.speed;
                }

                // Joystick kontrolleri - d√ºzeltilmi≈ü eksen sistemi
                moveX -= this.movement.joystick.x * Math.cos(cameraAngle) * this.movement.speed;
                moveZ += this.movement.joystick.x * Math.sin(cameraAngle) * this.movement.speed;
                moveX -= this.movement.joystick.y * Math.sin(cameraAngle) * this.movement.speed;
                moveZ -= this.movement.joystick.y * Math.cos(cameraAngle) * this.movement.speed;

                // Oyuncuyu hareket ettir
                const newX = this.sceneObjects.player.position.x + moveX;
                const newZ = this.sceneObjects.player.position.z + moveZ;

                // Sƒ±nƒ±r kontrol√º
                const halfWidth = this.worldMap.width / 2 - 2;
                const halfHeight = this.worldMap.height / 2 - 2;

                // Collision kontrol√º kaldƒ±rƒ±ldƒ± (daƒü ve aƒüa√ß yok)
                let canMove = true;

                if (Math.abs(newX) < halfWidth && Math.abs(newZ) < halfHeight && canMove) {
                    this.sceneObjects.player.position.x = newX;
                    this.sceneObjects.player.position.z = newZ;

                    // Oyuncu pozisyonunu g√ºncelle
                    this.worldMap.playerPosition.x = newX;
                    this.worldMap.playerPosition.z = newZ;

                    // ƒ∞zole bakƒ±≈ü a√ßƒ±sƒ± - oyuncu merkezde kalƒ±r
                    this.updateIsometricView();
                }

                // Kaynak toplama kontrol√º
                this.checkResourceCollection();
                
                // Altƒ±n toplama kontrol√º
                this.checkGoldCollection();
            }

            updateIsometricView() {
                if (!this.sceneObjects.player) return;

                // Oyuncuyu her zaman kamera merkezine ta≈üƒ±
                const playerWorldPos = this.sceneObjects.player.position.clone();
                
                // T√ºm sahne objelerini oyuncunun tersi y√∂nde hareket ettir
                const offsetX = -playerWorldPos.x;
                const offsetZ = -playerWorldPos.z;

                // D√ºnya objelerini hareket ettir
                if (this.sceneObjects.world) {
                    this.sceneObjects.world.ground.position.x = offsetX;
                    this.sceneObjects.world.ground.position.z = offsetZ;
                    this.sceneObjects.world.snow.position.x = offsetX;
                    this.sceneObjects.world.snow.position.z = offsetZ;
                }



                // Hayatta kalanlarƒ± hareket ettir
                this.sceneObjects.survivors.forEach(survivor => {
                    survivor.position.x += offsetX;
                    survivor.position.z += offsetZ;
                });

                // Yiyecek noktalarƒ±nƒ± hareket ettir
                this.sceneObjects.resourcePoints.forEach(food => {
                    food.position.x += offsetX;
                    food.position.z += offsetZ;
                });

                // Altƒ±nlarƒ± hareket ettir
                this.sceneObjects.goldCoins.forEach(coin => {
                    coin.position.x += offsetX;
                    coin.position.z += offsetZ;
                });

                // Yollarƒ± hareket ettir
                this.sceneObjects.roads.forEach(road => {
                    road.position.x += offsetX;
                    road.position.z += offsetZ;
                });

                // Evleri hareket ettir
                this.sceneObjects.houses.forEach(house => {
                    house.position.x += offsetX;
                    house.position.z += offsetZ;
                });

                // Tycoon platformlarƒ±nƒ± hareket ettir
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    platform.position.x += offsetX;
                    platform.position.z += offsetZ;
                });
                
                // Tycoon binalarƒ±nƒ± hareket ettir
                this.sceneObjects.tycoonBuildings.forEach(building => {
                    building.position.x += offsetX;
                    building.position.z += offsetZ;
                });

                // Kar sistemini hareket ettir
                if (this.sceneObjects.snowSystem) {
                    this.sceneObjects.snowSystem.position.x += offsetX;
                    this.sceneObjects.snowSystem.position.z += offsetZ;
                }

                // Oyuncuyu merkeze ta≈üƒ±
                this.sceneObjects.player.position.x = 0;
                this.sceneObjects.player.position.z = 0;
            }

            checkResourceCollection() {
                if (!this.sceneObjects.player) return;

                const playerPos = this.sceneObjects.player.position; // Her zaman (0, 1, 0)
                const collectionRange = 2;


                // Yiyecek noktalarƒ±nƒ± kontrol et - otomatik toplama
                this.sceneObjects.resourcePoints.forEach(food => {
                    const distance = Math.sqrt(food.position.x * food.position.x + food.position.z * food.position.z);
                    if (distance < collectionRange && food.userData.amount > 0) {
                        // Yiyecek topla
                        const collected = Math.min(10, food.userData.amount);
                        food.userData.amount -= collected;
                        this.gameState.food += collected;
                        
                        // Yiyecek biterse g√∂r√ºnmez yap
                        if (food.userData.amount <= 0) {
                            food.visible = false;
                        }
                    }
                });
            }

            checkGoldCollection() {
                if (!this.sceneObjects.player) return;

                const collectionRange = 1.5; // Altƒ±nlar i√ßin daha k√º√ß√ºk mesafe

                this.sceneObjects.goldCoins.forEach(coin => {
                    if (!coin.userData.collected) {
                        // Oyuncu merkezde olduƒüu i√ßin mesafe hesaplamasƒ± basit
                        const distance = Math.sqrt(coin.position.x * coin.position.x + coin.position.z * coin.position.z);
                        if (distance < collectionRange) {
                            // Altƒ±n toplandƒ±
                            coin.userData.collected = true;
                            coin.visible = false;
                            
                            // Puan ekle
                            this.gameState.score += coin.userData.value;
                            
                            // Haptic feedback (mobil)
                            if (this.detectMobile()) {
                                this.hapticFeedback();
                            }
                            
                            console.log(`Altƒ±n toplandƒ±! +${coin.userData.value} puan`);
                        }
                    }
                });
            }

            updateMinimap() {
                const ctx = this.minimapCtx;
                const canvas = this.minimapCanvas;
                
                // Minimap'i temizle
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Harita √∂l√ßeƒüi
                const scale = canvas.width / this.worldMap.width;
                
                // Oyuncu pozisyonu
                const playerX = (this.worldMap.playerPosition.x + this.worldMap.width/2) * scale;
                const playerZ = (this.worldMap.playerPosition.z + this.worldMap.height/2) * scale;

                // Oyuncu noktasƒ±
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
                ctx.fill();

                // Barƒ±nak (merkez)
                ctx.fillStyle = '#475569';
                ctx.fillRect(canvas.width/2 - 2, canvas.height/2 - 2, 4, 4);


                // Yiyecek noktalarƒ±
                ctx.fillStyle = '#fbbf24';
                this.sceneObjects.resourcePoints.forEach(food => {
                    if (food.userData.amount > 0) {
                        const x = (food.position.x + this.worldMap.width/2) * scale;
                        const z = (food.position.z + this.worldMap.height/2) * scale;
                        ctx.fillRect(x - 1, z - 1, 2, 2);
                    }
                });


                // Altƒ±nlar
                ctx.fillStyle = '#ffd700';
                this.sceneObjects.goldCoins.forEach(coin => {
                    if (!coin.userData.collected) {
                        const x = (coin.position.x + this.worldMap.width/2) * scale;
                        const z = (coin.position.z + this.worldMap.height/2) * scale;
                        ctx.beginPath();
                        ctx.arc(x, z, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Yollar
                ctx.fillStyle = '#6B7280';
                this.sceneObjects.roads.forEach(road => {
                    const x = (road.position.x + this.worldMap.width/2) * scale;
                    const z = (road.position.z + this.worldMap.height/2) * scale;
                    
                    // Yol boyutlarƒ±nƒ± minimap'e g√∂re ayarla
                    let roadWidth, roadHeight;
                    if (road.geometry.parameters.width > road.geometry.parameters.height) {
                        // Yatay yol
                        roadWidth = road.geometry.parameters.width * scale;
                        roadHeight = Math.max(2 * scale, 1); // Minimum 1 piksel
                    } else {
                        // Dikey yol
                        roadWidth = Math.max(2 * scale, 1); // Minimum 1 piksel
                        roadHeight = road.geometry.parameters.height * scale;
                    }
                    
                    ctx.fillRect(x - roadWidth/2, z - roadHeight/2, roadWidth, roadHeight);
                });

                // Fabrika zemini
                if (this.sceneObjects.factoryFloor) {
                    ctx.fillStyle = '#888888';
                    const factorySize = 15 * scale; // 15 birim fabrika boyutu
                    const factoryX = (0 + this.worldMap.width/2) * scale;
                    const factoryZ = (0 + this.worldMap.height/2) * scale;
                    ctx.fillRect(factoryX - factorySize/2, factoryZ - factorySize/2, factorySize, factorySize);
                }

                // Evler
                ctx.fillStyle = '#8B4513';
                this.sceneObjects.houses.forEach(house => {
                    const x = (house.position.x + this.worldMap.width/2) * scale;
                    const z = (house.position.z + this.worldMap.height/2) * scale;
                    ctx.fillRect(x - 2, z - 2, 4, 4);
                });
            }

            update3DAnimations() {
                const time = Date.now() * 0.001;

                // Oyuncu y√ºr√ºme animasyonu
                if (this.sceneObjects.player) {
                    const player = this.sceneObjects.player;
                    
                    // Hareket durumunu kontrol et
                    const isMoving = this.movement.keys.w || this.movement.keys.a || 
                                   this.movement.keys.s || this.movement.keys.d ||
                                   this.movement.keys.ArrowUp || this.movement.keys.ArrowLeft ||
                                   this.movement.keys.ArrowDown || this.movement.keys.ArrowRight ||
                                   Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1;
                    
                    if (isMoving) {
                        // Y√ºr√ºme animasyonu - bacaklarƒ± hareket ettir
                        const walkSpeed = 8; // Y√ºr√ºme hƒ±zƒ±
                        const legSwing = Math.sin(time * walkSpeed) * 0.3; // Bacak sallanma miktarƒ±
                        
                        // Sol bacak
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        if (leftLeg) {
                            leftLeg.rotation.x = legSwing;
                        }
                        
                        // Saƒü bacak
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        if (rightLeg) {
                            rightLeg.rotation.x = -legSwing; // Ters y√∂nde hareket
                        }
                        
                        // Kollarƒ± da hafif√ße salla
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftArm) leftArm.rotation.x = -legSwing * 0.5;
                        if (rightArm) rightArm.rotation.x = legSwing * 0.5;
                        
                        // Hafif yukarƒ±-a≈üaƒüƒ± hareket (adƒ±m atma efekti)
                        player.position.y = Math.abs(Math.sin(time * walkSpeed)) * 0.1;
                        
                        // Karakteri hareket y√∂n√ºne g√∂re d√∂nd√ºr
                        let targetRotation = 0;
                        
                        if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                            // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                            targetRotation = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ±
                        } else if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                            // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                            targetRotation = Math.atan2(-15, 15) + Math.PI;
                        } else if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                            // Sol - kameranƒ±n soluna doƒüru
                            targetRotation = Math.atan2(-15, 15) + Math.PI / 2;
                        } else if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                            // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                            targetRotation = Math.atan2(-15, 15) - Math.PI / 2;
                        }
                        
                        // Joystick i√ßin de d√∂nd√ºrme
                        if (Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1) {
                            targetRotation = Math.atan2(-this.movement.joystick.y, this.movement.joystick.x) + Math.atan2(-15, 15);
                        }
                        
                        // Yumu≈üak d√∂nd√ºrme
                        const rotationSpeed = 0.1;
                        const currentRotation = player.rotation.y;
                        const rotationDiff = targetRotation - currentRotation;
                        
                        // En kƒ±sa yolu bul (180 derece √ºzerinden d√∂nmemek i√ßin)
                        let shortestRotation = rotationDiff;
                        if (rotationDiff > Math.PI) shortestRotation -= 2 * Math.PI;
                        if (rotationDiff < -Math.PI) shortestRotation += 2 * Math.PI;
                        
                        player.rotation.y += shortestRotation * rotationSpeed;
                    } else {
                        // Durduƒüunda bacaklarƒ± d√ºzelt
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftLeg) leftLeg.rotation.x = 0;
                        if (rightLeg) rightLeg.rotation.x = 0;
                        if (leftArm) leftArm.rotation.x = 0;
                        if (rightArm) rightArm.rotation.x = 0;
                        
                        // Y pozisyonunu sƒ±fƒ±rla
                        player.position.y = 0;
                    }
                }

                // Kar animasyonu
                if (this.sceneObjects.snowSystem) {
                    const positions = this.sceneObjects.snowSystem.geometry.attributes.position.array;
                    const velocities = this.sceneObjects.snowSystem.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= velocities[i / 3] * this.gameState.stormIntensity * 0.01;
                        positions[i] += Math.sin(time + i) * 0.005 * this.gameState.stormIntensity;
                        
                        if (positions[i + 1] < -5) {
                            positions[i + 1] = 50;
                            positions[i] = (Math.random() - 0.5) * 100;
                            positions[i + 2] = (Math.random() - 0.5) * 100;
                        }
                    }
                    this.sceneObjects.snowSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Hayatta kalanlarƒ± animasyonla
                this.sceneObjects.survivors.forEach((survivor, index) => {
                    survivor.rotation.y += 0.01;
                    survivor.position.y = 0.75 + Math.sin(time * 2 + index) * 0.1;
                });
            }

            render() {
                // Three.js sahneyi render et - t√ºm objeleri her zaman render et
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // T√ºm objeleri g√∂r√ºn√ºr yap
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
                
                this.renderer.clear();
                this.renderer.render(this.scene, this.camera);
            }


            resourceDecayLoop() {
                if (this.gameState.isGameOver) return;

                // Kaynaklarƒ± azalt
                const heatDecay = 2 * this.gameState.stormIntensity;
                const foodDecay = 1 + (this.gameState.survivors * 0.5);
                
                this.gameState.heat = Math.max(0, this.gameState.heat - heatDecay);
                this.gameState.food = Math.max(0, this.gameState.food - foodDecay);
                
                this.updateUI();
                
                setTimeout(() => this.resourceDecayLoop(), 1000);
            }

            updateUI() {
                // Skor
                document.getElementById('scoreDisplay').textContent = `Skor: ${this.gameState.score}`;
                
                // Kaynaklar
                document.getElementById('heatBar').style.width = `${this.gameState.heat}%`;
                document.getElementById('foodBar').style.width = `${this.gameState.food}%`;
                document.getElementById('shelterBar').style.width = `${this.gameState.shelter}%`;
            }

            checkGameOver() {
                if (this.gameState.heat <= 0 || this.gameState.food <= 0) {
                    this.gameOver();
                }
            }

            gameOver() {
                this.gameState.isGameOver = true;
                // Se√ßim sistemi kaldƒ±rƒ±ldƒ±
                
                // Final skoru
                const finalScore = this.gameState.score + this.gameState.survivors * 5 + this.gameState.day;
                
                document.getElementById('finalScore').textContent = `Final Skor: ${finalScore}`;
                document.getElementById('gameOverScreen').classList.add('show');
                
                // Farcade'e bildir
                Farcade.gameOver({ score: finalScore });
            }

            restartGame() {
                // Oyun durumunu sƒ±fƒ±rla
                this.gameState = {
                    heat: 100,
                    food: 100,
                    shelter: 100,
                    survivors: 1,
                    day: 1,
                    score: 0,
                    isGameOver: false,
                    stormIntensity: 1,
                    lastStormIncrease: Date.now()
                };

                // UI'ƒ± sƒ±fƒ±rla
                this.updateUI();
                document.getElementById('gameOverScreen').classList.remove('show');
                // Se√ßim sistemi kaldƒ±rƒ±ldƒ±

                // Oyunu yeniden ba≈ülat
                this.startGame();
            }
        }

        // Oyunu ba≈ülat
        window.addEventListener('load', () => {
            new ColdHorizon3D();
        });

        // Farcade SDK event listeners
        window.addEventListener('play_again', () => {
            location.reload();
        });

        window.addEventListener('toggle_mute', () => {
            // Ses kontrol√º (≈üu anda ses yok)
            console.log('Ses a√ßƒ±k/kapalƒ±');
        });
    </script>
</body>
</html>
