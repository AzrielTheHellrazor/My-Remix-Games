<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cold Horizon 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            background: linear-gradient(180deg, #0a1929 0%, #1e3a5f 50%, #2d5aa0 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            height: 750px;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            border: 2px solid #334155;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }

        #gameCanvas {
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .top-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .score {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            color: #fbbf24;
            border: 2px solid #f59e0b;
        }

        .resources {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 15px;
            min-width: 120px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            font-size: 16px;
        }

        .resource-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .heat-fill { background: linear-gradient(90deg, #f97316 0%, #ea580c 100%); }
        .food-fill { background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%); }
        .shelter-fill { background: linear-gradient(90deg, #3b82f6 0%, #2563eb 100%); }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .game-over-screen.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .game-over-title {
            font-size: 48px;
            font-weight: bold;
            color: #60a5fa;
            text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
        }

        .final-score {
            font-size: 24px;
            color: #fbbf24;
        }

        .restart-btn {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s ease;
            pointer-events: all;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }


        /* Mobil Joystick */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .mobile-controls.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .joystick {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #3b82f6;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: 2px solid #ffffff;
            position: absolute;
            cursor: grab;
            transition: transform 0.1s ease;
        }

        .joystick-knob:active {
            cursor: grabbing;
        }

        /* Klavye kontrolleri g√∂stergesi */
        .keyboard-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Minimap */
        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #3b82f6;
            border-radius: 10px;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }


        @media (max-width: 520px) {
            .game-container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Three.js CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        
        <div class="ui-overlay">
            <div class="top-ui">
                <div class="score" id="scoreDisplay">Skor: 0</div>
                <div class="resources">
                    <div class="resource">
                        <div class="resource-icon">üî•</div>
                        <div class="resource-bar">
                            <div class="resource-fill heat-fill" id="heatBar" style="width: 100%"></div>
                        </div>
                    </div>
                    <div class="resource">
                        <div class="resource-icon">üçñ</div>
                        <div class="resource-bar">
                            <div class="resource-fill food-fill" id="foodBar" style="width: 100%"></div>
                        </div>
                    </div>
                    <div class="resource">
                        <div class="resource-icon">üè†</div>
                        <div class="resource-bar">
                            <div class="resource-fill shelter-fill" id="shelterBar" style="width: 100%"></div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Mobil Joystick -->
            <div class="mobile-controls" id="mobileControls">
                <div class="joystick">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>

            <!-- Klavye Kontrol√º G√∂stergesi -->
            <div class="keyboard-hint" id="keyboardHint">
                WASD / ‚Üê‚Üí‚Üë‚Üì Hareket
            </div>

            <!-- Minimap -->
            <div class="minimap" id="minimap">
                <canvas class="minimap-canvas" id="minimapCanvas"></canvas>
            </div>

            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over-title">DONDU!</div>
                <div class="final-score" id="finalScore">Final Skor: 0</div>
                <button class="restart-btn" id="restartBtn">Yeniden Ba≈üla</button>
            </div>
        </div>
    </div>

    <script>
        // Farcade SDK Mock (ger√ßek SDK y√ºklendiƒüinde deƒüi≈ütirilecek)
        const Farcade = {
            ready: () => console.log('Farcade ready'),
            gameOver: (data) => console.log('Game over:', data),
            hapticFeedback: () => {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
        };

        class ColdHorizon3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                
                // Canvas boyutlarƒ±nƒ± ayarla
                this.setupCanvas();
                
                // Three.js sahne olu≈ütur
                this.initThreeJS();
                
                // Oyun durumu
                this.gameState = {
                    heat: 100,
                    food: 100,
                    shelter: 100,
                    survivors: 1,
                    day: 1,
                    score: 0,
                    isGameOver: false,
                    stormIntensity: 1,
                    lastStormIncrease: Date.now()
                };

                // 3D objeler
                this.sceneObjects = {
                    shelter: null,
                    fire: null,
                    survivors: [],
                    snowSystem: null,
                    player: null,
                    resourcePoints: [],
                    goldCoins: [],
                    roads: [],
                    houses: [],
                    factoryFloor: null,
                    world: null
                };

                // Hareket sistemi
                this.movement = {
                    keys: {
                        w: false, a: false, s: false, d: false,
                        ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
                    },
                    speed: 0.3,
                    joystick: { x: 0, y: 0 }
                };

                // Harita sistemi
                this.worldMap = {
                    width: 100,
                    height: 100,
                    playerPosition: { x: 0, y: 0, z: 0 }
                };

                // Minimap
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.setupMinimap();
                

                // Event listeners
                this.setupEventListeners();
                
                // 3D sahneyi olu≈ütur
                this.create3DScene();
                
                // Oyunu ba≈ülat
                this.startGame();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                this.width = rect.width;
                this.height = rect.height;
            }

            initThreeJS() {
                // Sahne olu≈ütur
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0f172a, 50, 200);

                // Kamera olu≈ütur (perspektif kamera)
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    this.width / this.height, 
                    0.1, 
                    1000
                );
                // Kamerayƒ± Y ekseni sabit kalacak ≈üekilde ters y√∂nde d√∂nd√ºr (yakƒ±nla≈ütƒ±rƒ±lmƒ±≈ü)
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // Kamera frustum ayarlarƒ±
                this.camera.far = 1000;
                this.camera.near = 0.1;
                
                // Kamerayƒ± tamamen sabitle
                this.camera.position.x = -15;
                this.camera.position.y = 20;
                this.camera.position.z = 15;

                // Renderer olu≈ütur
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: false,
                    logarithmicDepthBuffer: false
                });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = false; // G√∂lgeleri kapat
                this.renderer.setClearColor(0x0f172a, 1);
                
                // Render optimizasyonlarƒ±nƒ± kapat
                this.renderer.sortObjects = false;
                this.renderer.autoClear = true;
                
                // Frustum culling'i tamamen kapat
                this.renderer.setClearColor(0x0f172a, 1);
                this.scene.autoUpdate = true;

                // I≈üƒ±klandƒ±rma
                this.setupLighting();

                // Kamera kontrolleri
                this.setupCameraControls();
            }

            setupLighting() {
                // Ambient ƒ±≈üƒ±k (genel aydƒ±nlatma)
                const ambientLight = new THREE.AmbientLight(0x334155, 0.3);
                this.scene.add(ambientLight);

                // Direkt ƒ±≈üƒ±k (g√ºne≈ü)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Ate≈ü ƒ±≈üƒ±ƒüƒ± (point light)
                this.fireLight = new THREE.PointLight(0xf97316, 2, 15);
                this.fireLight.position.set(0, 2, 0);
                this.fireLight.castShadow = true;
                this.scene.add(this.fireLight);
            }

            setupCameraControls() {
                // Kamera tamamen sabit - hi√ßbir kontrol yok
            }

            setupEventListeners() {
                // Klavye kontrolleri
                document.addEventListener('keydown', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = true;
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = false;
                        e.preventDefault();
                    }
                });

                // Dokunmatik kontroller (artƒ±k sadece joystick i√ßin)

                // Yeniden ba≈ülat
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                    Farcade.hapticFeedback();
                });

                // Mobil joystick
                this.setupJoystick();

                // Mobil kontrolleri g√∂ster/gizle
                this.detectMobile();

                // Resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
            }

            detectMobile() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const mobileControls = document.getElementById('mobileControls');
                const keyboardHint = document.getElementById('keyboardHint');
                
                if (isMobile) {
                    mobileControls.classList.add('show');
                    keyboardHint.style.display = 'none';
                } else {
                    mobileControls.classList.remove('show');
                    keyboardHint.style.display = 'block';
                }
            }

            setupJoystick() {
                const joystick = document.getElementById('joystickKnob');
                let isDragging = false;
                let startPos = { x: 0, y: 0 };

                joystick.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                joystick.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    
                    const touch = e.touches[0];
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                    
                    e.preventDefault();
                });

                joystick.addEventListener('touchend', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });

                // Mouse desteƒüi (masa√ºst√º test i√ßin)
                joystick.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = e.clientX - centerX;
                    const deltaY = e.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });
            }

            setupMinimap() {
                this.minimapCanvas.width = 150;
                this.minimapCanvas.height = 150;
            }

            create3DScene() {
                this.createWorld();
                this.createPlayer();
                this.createRoads();
                this.createFactoryFloor();
                this.createHouses();
                this.createSurvivors();
                this.createResourcePoints();
                this.createGoldCoins();
                this.createSnowSystem();
                
                // T√ºm objeleri ba≈ütan render et
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
            }

            createWorld() {
                // T√ºm harita ba≈ütan y√ºklensin - b√ºy√ºk d√ºnya zemini
                const groundGeometry = new THREE.PlaneGeometry(this.worldMap.width, this.worldMap.height);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1e293b,
                    transparent: false,
                    opacity: 1.0
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                ground.frustumCulled = false; // T√ºm harita her zaman g√∂r√ºn√ºr
                ground.visible = true;
                this.scene.add(ground);

                // T√ºm kar zemini y√ºklensin
                const snowGeometry = new THREE.PlaneGeometry(this.worldMap.width + 20, this.worldMap.height + 20);
                const snowMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf8fafc,
                    transparent: true,
                    opacity: 0.6
                });
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                snow.rotation.x = -Math.PI / 2;
                snow.position.y = 0.01;
                snow.frustumCulled = false; // T√ºm kar zemini her zaman g√∂r√ºn√ºr
                snow.visible = true;
                this.scene.add(snow);

                // D√ºnya sƒ±nƒ±rlarƒ± (g√∂r√ºnmez duvarlar)
                this.createWorldBounds();

                this.sceneObjects.world = { ground, snow };
            }

            createWorldBounds() {
                // D√ºnya sƒ±nƒ±rlarƒ± i√ßin g√∂r√ºnmez duvarlar
                const bounds = [
                    { pos: [0, 25, this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // Arka
                    { pos: [0, 25, -this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // √ñn
                    { pos: [this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }, // Saƒü
                    { pos: [-this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }  // Sol
                ];

                bounds.forEach(bound => {
                    const geometry = new THREE.BoxGeometry(bound.size[0], bound.size[1], bound.size[2]);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0 
                    });
                    const wall = new THREE.Mesh(geometry, material);
                    wall.position.set(bound.pos[0], bound.pos[1], bound.pos[2]);
                    wall.userData = { isBoundary: true };
                    wall.frustumCulled = false; // Frustum culling'i devre dƒ±≈üƒ± bƒ±rak
                    this.scene.add(wall);
                });
            }

            createPlayer() {
                // ƒ∞nsan ≈üeklinde oyuncu karakteri olu≈ütur
                const player = new THREE.Group();
                
                // V√ºcut (ana g√∂vde) - daha b√ºy√ºk
                const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.4, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3b82f6 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                body.castShadow = true;
                player.add(body);

                // Kafa - daha b√ºy√ºk
                const headGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.0;
                head.castShadow = true;
                player.add(head);

                // Sa√ß - daha b√ºy√ºk
                const hairGeometry = new THREE.SphereGeometry(0.54, 8, 6);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 3.1;
                hair.scale.y = 0.7;
                player.add(hair);

                // Sol kol - daha b√ºy√ºk
                const leftArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
                leftArm.position.set(-0.8, 1.6, 0);
                leftArm.rotation.z = 0.3;
                leftArm.castShadow = true;
                player.add(leftArm);

                // Saƒü kol - daha b√ºy√ºk
                const rightArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
                rightArm.position.set(0.8, 1.6, 0);
                rightArm.rotation.z = -0.3;
                rightArm.castShadow = true;
                player.add(rightArm);

                // Sol bacak - daha b√ºy√ºk
                const leftLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                const leftLeg = new THREE.Mesh(leftLegGeometry, legMaterial);
                leftLeg.position.set(-0.3, -1.0, 0);
                leftLeg.castShadow = true;
                player.add(leftLeg);

                // Saƒü bacak - daha b√ºy√ºk
                const rightLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const rightLeg = new THREE.Mesh(rightLegGeometry, legMaterial);
                rightLeg.position.set(0.3, -1.0, 0);
                rightLeg.castShadow = true;
                player.add(rightLeg);

                // Ayaklar - daha b√ºy√ºk
                const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.8);
                const footMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                
                const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                leftFoot.position.set(-0.3, -2.1, 0.2);
                leftFoot.castShadow = true;
                player.add(leftFoot);

                const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                rightFoot.position.set(0.3, -2.1, 0.2);
                rightFoot.castShadow = true;
                player.add(rightFoot);

                // Oyuncuyu sahneye ekle
                player.position.set(0, 0, 0);
                this.scene.add(player);

                this.sceneObjects.player = player;
            }


            createResourcePoints() {

                // Yiyecek noktalarƒ±
                const foodCount = 15;
                for (let i = 0; i < foodCount; i++) {
                    const foodGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                    const foodMaterial = new THREE.MeshLambertMaterial({ color: 0xfbbf24 });
                    const food = new THREE.Mesh(foodGeometry, foodMaterial);
                    
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * (this.worldMap.width - 20);
                        z = (Math.random() - 0.5) * (this.worldMap.height - 20);
                    } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                    
                    food.position.set(x, 0.25, z);
                    food.castShadow = true;
                    food.frustumCulled = false; // Frustum culling'i devre dƒ±≈üƒ± bƒ±rak
                    food.userData = { type: 'food', resource: 'food', amount: 50 };
                    this.scene.add(food);
                    
                    this.sceneObjects.resourcePoints.push(food);
                }
            }

            createRoads() {
                // YENƒ∞ YOL Sƒ∞STEMƒ∞ - Fabrika alanƒ± hari√ß
                console.log("Yollar olu≈üturuluyor...");
                
                const roadWidth = 5.0;
                const roadSpacing = 10;
                const roadColor = 0x404040; // Koyu gri
                const factoryArea = 15; // Fabrika alanƒ± boyutu
                
                // Yol materyali
                const roadMaterial = new THREE.MeshLambertMaterial({ 
                    color: roadColor
                });

                // Dikey yollar (X ekseni boyunca) - Fabrika alanƒ±ndan uzakta
                for (let x = -this.worldMap.width/2; x <= this.worldMap.width/2; x += roadSpacing) {
                    // Fabrika alanƒ±ndan tamamen uzakta olan yollar
                    if (Math.abs(x) > factoryArea/2) {
                        this.createSimpleRoad(x, 0, 0, roadWidth, this.worldMap.height, roadMaterial);
                    }
                }

                // Yatay yollar (Z ekseni boyunca) - Fabrika alanƒ±ndan uzakta
                for (let z = -this.worldMap.height/2; z <= this.worldMap.height/2; z += roadSpacing) {
                    // Fabrika alanƒ±ndan tamamen uzakta olan yollar
                    if (Math.abs(z) > factoryArea/2) {
                        this.createSimpleRoad(0, 0, z, this.worldMap.width, roadWidth, roadMaterial);
                    }
                }
                
                console.log(`Toplam ${this.sceneObjects.roads.length} yol olu≈üturuldu (fabrika alanƒ± hari√ß)`);
            }

            createSimpleRoad(x, y, z, width, length, material) {
                // Basit yol olu≈ütur - BoxGeometry kullan
                const roadGeometry = new THREE.BoxGeometry(width, 0.2, length);
                const roadMesh = new THREE.Mesh(roadGeometry, material);
                
                // Pozisyon
                roadMesh.position.set(x, y + 0.1, z);
                
                // G√∂r√ºn√ºrl√ºk ayarlarƒ±
                roadMesh.frustumCulled = false;
                roadMesh.userData = { type: 'road' };
                
                // Sahneye ekle
                this.scene.add(roadMesh);
                this.sceneObjects.roads.push(roadMesh);
                
                console.log(`Yol olu≈üturuldu: x=${x}, z=${z}, w=${width}, l=${length}`);
            }

            createFactoryFloor() {
                // Fabrika zemini - ba≈ülangƒ±√ß alanƒ±nda
                console.log("Fabrika zemini olu≈üturuluyor...");
                
                const factorySize = 15; // 15x15 birimkare - √ßok daha b√ºy√ºk
                const factoryMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x888888, // √áok parlak gri fabrika zemini
                    transparent: false,
                    opacity: 1.0
                });
                
                // Fabrika zemini olu≈ütur - BoxGeometry ile kalƒ±n zemin
                const factoryGeometry = new THREE.BoxGeometry(factorySize, 0.3, factorySize);
                const factoryFloor = new THREE.Mesh(factoryGeometry, factoryMaterial);
                
                // Zemin pozisyonu (merkez alan)
                factoryFloor.position.set(0, 0.3, 0); // √áok daha y√ºksekte
                factoryFloor.castShadow = true;
                factoryFloor.receiveShadow = true;
                factoryFloor.userData = { type: 'factoryFloor' };
                
                this.scene.add(factoryFloor);
                this.sceneObjects.factoryFloor = factoryFloor;
                
                console.log("Fabrika zemini olu≈üturuldu - BoxGeometry ile");
            }

            createHouses() {
                // YENƒ∞ EV Sƒ∞STEMƒ∞ - Ba≈ülangƒ±√ß alanƒ± hari√ß
                console.log("Evler olu≈üturuluyor...");
                
                const roadSpacing = 10; // Yol aralƒ±ƒüƒ±
                const houseSpacing = 3; // Evler arasƒ± mesafe - daha sƒ±k
                const houseMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513
                });

                // Ba≈ülangƒ±√ß alanƒ± boyutlarƒ± (15x15 birimkare)
                const startAreaSize = 15;

                // Her yol bloƒüunun ortasƒ±nda evler olu≈ütur
                for (let x = -this.worldMap.width/2 + roadSpacing; x < this.worldMap.width/2 - roadSpacing; x += roadSpacing) {
                    for (let z = -this.worldMap.height/2 + roadSpacing; z < this.worldMap.height/2 - roadSpacing; z += roadSpacing) {
                        // Bu blokun tam ortasƒ±nda evler olu≈ütur
                        const blockCenterX = x + roadSpacing/2;
                        const blockCenterZ = z + roadSpacing/2;
                        
                        // Ba≈ülangƒ±√ß alanƒ±nda ev olu≈üturma (merkez alan) - Kesin kontrol
                        const isInStartArea = Math.abs(blockCenterX) <= startAreaSize/2 && Math.abs(blockCenterZ) <= startAreaSize/2;
                        
                        if (!isInStartArea) {
                            // Her blokta 1 tane b√ºy√ºk ev olu≈ütur - tam ortada
                            const houseX = blockCenterX;
                            const houseZ = blockCenterZ;
                            
                            // Yol √ºzerinde deƒüilse ev olu≈ütur
                            const isOnRoad = this.isPositionOnRoad(houseX, houseZ, roadSpacing);
                            if (!isOnRoad) {
                                const house = this.createHouse(houseX, houseZ, houseMaterial);
                                this.sceneObjects.houses.push(house);
                            }
                        }
                    }
                }
                
                console.log(`Toplam ${this.sceneObjects.houses.length} ev olu≈üturuldu`);
            }

            isPositionOnRoad(x, z, roadSpacing) {
                // Pozisyonun yol √ºzerinde olup olmadƒ±ƒüƒ±nƒ± kontrol et
                const tolerance = 2.5; // Yol kenarƒ± toleransƒ± (yol geni≈üliƒüi/2)
                const factoryArea = 15; // Fabrika alanƒ± boyutu
                
                // Fabrika alanƒ±ndaysa yol kontrol√º yapma (fabrika alanƒ±nda yol yok)
                if (Math.abs(x) <= factoryArea/2 && Math.abs(z) <= factoryArea/2) {
                    return false;
                }
                
                // Dikey yollar i√ßin kontrol - Fabrika alanƒ±ndan uzakta olanlar
                for (let roadX = -this.worldMap.width/2; roadX <= this.worldMap.width/2; roadX += roadSpacing) {
                    if (Math.abs(roadX) > factoryArea/2 && Math.abs(x - roadX) < tolerance) {
                        return true;
                    }
                }
                
                // Yatay yollar i√ßin kontrol - Fabrika alanƒ±ndan uzakta olanlar
                for (let roadZ = -this.worldMap.height/2; roadZ <= this.worldMap.height/2; roadZ += roadSpacing) {
                    if (Math.abs(roadZ) > factoryArea/2 && Math.abs(z - roadZ) < tolerance) {
                        return true;
                    }
                }
                
                return false;
            }

            createHouse(x, z, material) {
                // Ev olu≈ütur
                const houseGroup = new THREE.Group();
                
                // Ev boyutlarƒ± - b√ºy√ºk ev
                const houseWidth = 6;
                const houseHeight = 8;
                const houseDepth = 6;
                
                // Ana ev binasƒ±
                const mainHouse = new THREE.Mesh(
                    new THREE.BoxGeometry(houseWidth, houseHeight, houseDepth),
                    material
                );
                mainHouse.position.set(0, houseHeight/2, 0);
                mainHouse.castShadow = true;
                mainHouse.receiveShadow = true;
                houseGroup.add(mainHouse);
                
                // Ev √ßatƒ±sƒ±
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(houseWidth * 0.8, houseHeight * 0.3, 4),
                    new THREE.MeshLambertMaterial({ color: 0x8B0000 })
                );
                roof.position.set(0, houseHeight + houseHeight * 0.15, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                houseGroup.add(roof);
                
                // Ev kapƒ±sƒ±
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 4, 0.2),
                    new THREE.MeshLambertMaterial({ color: 0x654321 })
                );
                door.position.set(0, 2, houseDepth/2 + 0.1);
                houseGroup.add(door);
                
                // Ev pencereleri
                const windowPositions = [
                    { x: -houseWidth/3, y: 4, z: houseDepth/2 + 0.1 },
                    { x: houseWidth/3, y: 4, z: houseDepth/2 + 0.1 },
                    { x: houseWidth/2 + 0.1, y: 4, z: 0 }
                ];
                
                windowPositions.forEach(windowPos => {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 1.5, 0.1),
                        new THREE.MeshLambertMaterial({ color: 0x87CEEB })
                    );
                    window.position.set(windowPos.x, windowPos.y, windowPos.z);
                    houseGroup.add(window);
                });
                
                houseGroup.position.set(x, 0, z);
                houseGroup.frustumCulled = false;
                houseGroup.userData = { type: 'house' };
                this.scene.add(houseGroup);
                
                return houseGroup;
            }

            createGoldCoins() {
                // Altƒ±n paralar olu≈ütur
                const goldCount = 25;
                for (let i = 0; i < goldCount; i++) {
                    const goldGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
                    const goldMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffd700, // Altƒ±n rengi
                        emissive: 0x332200 // Hafif parƒ±ltƒ±
                    });
                    const goldCoin = new THREE.Mesh(goldGeometry, goldMaterial);
                    
                    // Rastgele pozisyon (barƒ±nak √ßevresinde deƒüil)
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * (this.worldMap.width - 20);
                        z = (Math.random() - 0.5) * (this.worldMap.height - 20);
                    } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                    
                    goldCoin.position.set(x, 0.05, z);
                    goldCoin.castShadow = true;
                    goldCoin.frustumCulled = false;
                    goldCoin.userData = { 
                        type: 'gold', 
                        value: Math.floor(Math.random() * 50) + 10, // 10-60 puan
                        collected: false
                    };
                    this.scene.add(goldCoin);
                    
                    this.sceneObjects.goldCoins.push(goldCoin);
                }
            }

            createShelter() {
                // Barƒ±nak duvarlarƒ±
                const wallGeometry = new THREE.BoxGeometry(8, 4, 6);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x475569 });
                
                // Arka duvar
                const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
                backWall.position.set(0, 2, -3);
                backWall.castShadow = true;
                this.scene.add(backWall);

                // Sol duvar
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                leftWall.position.set(-4, 2, 0);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.castShadow = true;
                this.scene.add(leftWall);

                // Saƒü duvar
                const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
                rightWall.position.set(4, 2, 0);
                rightWall.rotation.y = Math.PI / 2;
                rightWall.castShadow = true;
                this.scene.add(rightWall);

                // √áatƒ±
                const roofGeometry = new THREE.ConeGeometry(6, 3, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x64748b });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 5, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                this.scene.add(roof);

                this.sceneObjects.shelter = { backWall, leftWall, rightWall, roof };
            }


            createFire() {
                // Ate≈ü geometrisi
                const fireGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                const fireMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf97316,
                    emissive: 0xf97316,
                    emissiveIntensity: 0.5
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set(0, 1, 0);
                fire.castShadow = true;
                this.scene.add(fire);

                // Ate≈ü partik√ºlleri
                const particleCount = 50;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 2;
                    positions[i * 3 + 1] = Math.random() * 3;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

                    const color = new THREE.Color();
                    color.setHSL(0.1, 1, Math.random() * 0.5 + 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });

                const fireParticles = new THREE.Points(particles, particleMaterial);
                fireParticles.position.set(0, 1, 0);
                this.scene.add(fireParticles);

                this.sceneObjects.fire = { fire, particles: fireParticles };
            }

            createSurvivors() {
                // Hayatta kalan karakterleri olu≈ütur
                for (let i = 0; i < this.gameState.survivors; i++) {
                    this.addSurvivor(i);
                }
            }

            addSurvivor(index) {
                const survivorGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
                const survivorMaterial = new THREE.MeshLambertMaterial({ color: 0xfbbf24 });
                const survivor = new THREE.Mesh(survivorGeometry, survivorMaterial);
                
                const angle = (index / this.gameState.survivors) * Math.PI * 2;
                survivor.position.set(
                    Math.cos(angle) * 6,
                    0.75,
                    Math.sin(angle) * 6
                );
                survivor.castShadow = true;
                this.scene.add(survivor);
                
                this.sceneObjects.survivors.push(survivor);
            }

            createSnowSystem() {
                // Kar sistemi - ba≈ütan render et, t√ºm harita alanƒ±na
                const snowCount = 2000; // Daha fazla kar par√ßacƒ±ƒüƒ±
                const snowGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(snowCount * 3);
                const velocities = new Float32Array(snowCount);

                // T√ºm harita alanƒ±na kar par√ßacƒ±klarƒ± yerle≈ütir
                for (let i = 0; i < snowCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * (this.worldMap.width + 50);
                    positions[i * 3 + 1] = Math.random() * 80 + 20; // Daha y√ºksekten ba≈üla
                    positions[i * 3 + 2] = (Math.random() - 0.5) * (this.worldMap.height + 50);
                    velocities[i] = Math.random() * 2 + 1;
                }

                snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

                const snowMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.9
                });

                const snowSystem = new THREE.Points(snowGeometry, snowMaterial);
                snowSystem.frustumCulled = false; // Her zaman render et
                snowSystem.visible = true;
                this.scene.add(snowSystem);
                
                this.sceneObjects.snowSystem = snowSystem;
            }

            startGame() {
                this.gameLoop();
                this.resourceDecayLoop();
                Farcade.ready();
            }

            gameLoop() {
                if (this.gameState.isGameOver) return;

                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                // Fƒ±rtƒ±na yoƒüunluƒüunu artƒ±r
                const now = Date.now();
                if (now - this.gameState.lastStormIncrease > 30000) { // 30 saniye
                    this.gameState.stormIntensity += 0.2;
                    this.gameState.lastStormIncrease = now;
                }

                // Oyuncu hareketi
                this.updatePlayerMovement();

                // 3D animasyonlarƒ± g√ºncelle
                this.update3DAnimations();

                // Minimap g√ºncelle
                this.updateMinimap();

                // Oyun bitti mi kontrol et
                this.checkGameOver();
            }

            updatePlayerMovement() {
                if (!this.sceneObjects.player) return;

                let moveX = 0;
                let moveZ = 0;

                // Kamera a√ßƒ±sƒ±na g√∂re hareket eksenlerini ayarla
                // Kamera (-15, 20, 15) pozisyonunda, merkeze bakƒ±yor
                // Bu y√ºzden hareket eksenlerini kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re ayarlayalƒ±m
                const cameraAngle = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ± (g√ºncellenmi≈ü)

                // Klavye kontrolleri - kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re (d√ºzeltilmi≈ü y√∂nler)
                if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                    // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                    moveX -= Math.sin(cameraAngle) * this.movement.speed;
                    moveZ -= Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                    // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                    moveX += Math.sin(cameraAngle) * this.movement.speed;
                    moveZ += Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                    // Sol - kameranƒ±n soluna doƒüru
                    moveX -= Math.cos(cameraAngle) * this.movement.speed;
                    moveZ += Math.sin(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                    // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                    moveX += Math.cos(cameraAngle) * this.movement.speed;
                    moveZ -= Math.sin(cameraAngle) * this.movement.speed;
                }

                // Joystick kontrolleri - d√ºzeltilmi≈ü eksen sistemi
                moveX -= this.movement.joystick.x * Math.cos(cameraAngle) * this.movement.speed;
                moveZ += this.movement.joystick.x * Math.sin(cameraAngle) * this.movement.speed;
                moveX -= this.movement.joystick.y * Math.sin(cameraAngle) * this.movement.speed;
                moveZ -= this.movement.joystick.y * Math.cos(cameraAngle) * this.movement.speed;

                // Oyuncuyu hareket ettir
                const newX = this.sceneObjects.player.position.x + moveX;
                const newZ = this.sceneObjects.player.position.z + moveZ;

                // Sƒ±nƒ±r kontrol√º
                const halfWidth = this.worldMap.width / 2 - 2;
                const halfHeight = this.worldMap.height / 2 - 2;

                // Collision kontrol√º kaldƒ±rƒ±ldƒ± (daƒü ve aƒüa√ß yok)
                let canMove = true;

                if (Math.abs(newX) < halfWidth && Math.abs(newZ) < halfHeight && canMove) {
                    this.sceneObjects.player.position.x = newX;
                    this.sceneObjects.player.position.z = newZ;

                    // Oyuncu pozisyonunu g√ºncelle
                    this.worldMap.playerPosition.x = newX;
                    this.worldMap.playerPosition.z = newZ;

                    // ƒ∞zole bakƒ±≈ü a√ßƒ±sƒ± - oyuncu merkezde kalƒ±r
                    this.updateIsometricView();
                }

                // Kaynak toplama kontrol√º
                this.checkResourceCollection();
                
                // Altƒ±n toplama kontrol√º
                this.checkGoldCollection();
            }

            updateIsometricView() {
                if (!this.sceneObjects.player) return;

                // Oyuncuyu her zaman kamera merkezine ta≈üƒ±
                const playerWorldPos = this.sceneObjects.player.position.clone();
                
                // T√ºm sahne objelerini oyuncunun tersi y√∂nde hareket ettir
                const offsetX = -playerWorldPos.x;
                const offsetZ = -playerWorldPos.z;

                // D√ºnya objelerini hareket ettir
                if (this.sceneObjects.world) {
                    this.sceneObjects.world.ground.position.x = offsetX;
                    this.sceneObjects.world.ground.position.z = offsetZ;
                    this.sceneObjects.world.snow.position.x = offsetX;
                    this.sceneObjects.world.snow.position.z = offsetZ;
                }



                // Hayatta kalanlarƒ± hareket ettir
                this.sceneObjects.survivors.forEach(survivor => {
                    survivor.position.x += offsetX;
                    survivor.position.z += offsetZ;
                });

                // Yiyecek noktalarƒ±nƒ± hareket ettir
                this.sceneObjects.resourcePoints.forEach(food => {
                    food.position.x += offsetX;
                    food.position.z += offsetZ;
                });

                // Altƒ±nlarƒ± hareket ettir
                this.sceneObjects.goldCoins.forEach(coin => {
                    coin.position.x += offsetX;
                    coin.position.z += offsetZ;
                });

                // Yollarƒ± hareket ettir
                this.sceneObjects.roads.forEach(road => {
                    road.position.x += offsetX;
                    road.position.z += offsetZ;
                });

                // Evleri hareket ettir
                this.sceneObjects.houses.forEach(house => {
                    house.position.x += offsetX;
                    house.position.z += offsetZ;
                });

                // Kar sistemini hareket ettir
                if (this.sceneObjects.snowSystem) {
                    this.sceneObjects.snowSystem.position.x += offsetX;
                    this.sceneObjects.snowSystem.position.z += offsetZ;
                }

                // Oyuncuyu merkeze ta≈üƒ±
                this.sceneObjects.player.position.x = 0;
                this.sceneObjects.player.position.z = 0;
            }

            checkResourceCollection() {
                if (!this.sceneObjects.player) return;

                const playerPos = this.sceneObjects.player.position; // Her zaman (0, 1, 0)
                const collectionRange = 2;


                // Yiyecek noktalarƒ±nƒ± kontrol et - otomatik toplama
                this.sceneObjects.resourcePoints.forEach(food => {
                    const distance = Math.sqrt(food.position.x * food.position.x + food.position.z * food.position.z);
                    if (distance < collectionRange && food.userData.amount > 0) {
                        // Yiyecek topla
                        const collected = Math.min(10, food.userData.amount);
                        food.userData.amount -= collected;
                        this.gameState.food += collected;
                        
                        // Yiyecek biterse g√∂r√ºnmez yap
                        if (food.userData.amount <= 0) {
                            food.visible = false;
                        }
                    }
                });
            }

            checkGoldCollection() {
                if (!this.sceneObjects.player) return;

                const collectionRange = 1.5; // Altƒ±nlar i√ßin daha k√º√ß√ºk mesafe

                this.sceneObjects.goldCoins.forEach(coin => {
                    if (!coin.userData.collected) {
                        // Oyuncu merkezde olduƒüu i√ßin mesafe hesaplamasƒ± basit
                        const distance = Math.sqrt(coin.position.x * coin.position.x + coin.position.z * coin.position.z);
                        if (distance < collectionRange) {
                            // Altƒ±n toplandƒ±
                            coin.userData.collected = true;
                            coin.visible = false;
                            
                            // Puan ekle
                            this.gameState.score += coin.userData.value;
                            
                            // Haptic feedback (mobil)
                            if (this.detectMobile()) {
                                this.hapticFeedback();
                            }
                            
                            console.log(`Altƒ±n toplandƒ±! +${coin.userData.value} puan`);
                        }
                    }
                });
            }

            updateMinimap() {
                const ctx = this.minimapCtx;
                const canvas = this.minimapCanvas;
                
                // Minimap'i temizle
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Harita √∂l√ßeƒüi
                const scale = canvas.width / this.worldMap.width;
                
                // Oyuncu pozisyonu
                const playerX = (this.worldMap.playerPosition.x + this.worldMap.width/2) * scale;
                const playerZ = (this.worldMap.playerPosition.z + this.worldMap.height/2) * scale;

                // Oyuncu noktasƒ±
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
                ctx.fill();

                // Barƒ±nak (merkez)
                ctx.fillStyle = '#475569';
                ctx.fillRect(canvas.width/2 - 2, canvas.height/2 - 2, 4, 4);


                // Yiyecek noktalarƒ±
                ctx.fillStyle = '#fbbf24';
                this.sceneObjects.resourcePoints.forEach(food => {
                    if (food.userData.amount > 0) {
                        const x = (food.position.x + this.worldMap.width/2) * scale;
                        const z = (food.position.z + this.worldMap.height/2) * scale;
                        ctx.fillRect(x - 1, z - 1, 2, 2);
                    }
                });


                // Altƒ±nlar
                ctx.fillStyle = '#ffd700';
                this.sceneObjects.goldCoins.forEach(coin => {
                    if (!coin.userData.collected) {
                        const x = (coin.position.x + this.worldMap.width/2) * scale;
                        const z = (coin.position.z + this.worldMap.height/2) * scale;
                        ctx.beginPath();
                        ctx.arc(x, z, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Yollar
                ctx.fillStyle = '#6B7280';
                this.sceneObjects.roads.forEach(road => {
                    const x = (road.position.x + this.worldMap.width/2) * scale;
                    const z = (road.position.z + this.worldMap.height/2) * scale;
                    
                    // Yol boyutlarƒ±nƒ± minimap'e g√∂re ayarla
                    let roadWidth, roadHeight;
                    if (road.geometry.parameters.width > road.geometry.parameters.height) {
                        // Yatay yol
                        roadWidth = road.geometry.parameters.width * scale;
                        roadHeight = Math.max(2 * scale, 1); // Minimum 1 piksel
                    } else {
                        // Dikey yol
                        roadWidth = Math.max(2 * scale, 1); // Minimum 1 piksel
                        roadHeight = road.geometry.parameters.height * scale;
                    }
                    
                    ctx.fillRect(x - roadWidth/2, z - roadHeight/2, roadWidth, roadHeight);
                });

                // Fabrika zemini
                if (this.sceneObjects.factoryFloor) {
                    ctx.fillStyle = '#888888';
                    const factorySize = 15 * scale; // 15 birim fabrika boyutu
                    const factoryX = (0 + this.worldMap.width/2) * scale;
                    const factoryZ = (0 + this.worldMap.height/2) * scale;
                    ctx.fillRect(factoryX - factorySize/2, factoryZ - factorySize/2, factorySize, factorySize);
                }

                // Evler
                ctx.fillStyle = '#8B4513';
                this.sceneObjects.houses.forEach(house => {
                    const x = (house.position.x + this.worldMap.width/2) * scale;
                    const z = (house.position.z + this.worldMap.height/2) * scale;
                    ctx.fillRect(x - 2, z - 2, 4, 4);
                });
            }

            update3DAnimations() {
                const time = Date.now() * 0.001;

                // Oyuncu y√ºr√ºme animasyonu
                if (this.sceneObjects.player) {
                    const player = this.sceneObjects.player;
                    
                    // Hareket durumunu kontrol et
                    const isMoving = this.movement.keys.w || this.movement.keys.a || 
                                   this.movement.keys.s || this.movement.keys.d ||
                                   this.movement.keys.ArrowUp || this.movement.keys.ArrowLeft ||
                                   this.movement.keys.ArrowDown || this.movement.keys.ArrowRight ||
                                   Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1;
                    
                    if (isMoving) {
                        // Y√ºr√ºme animasyonu - bacaklarƒ± hareket ettir
                        const walkSpeed = 8; // Y√ºr√ºme hƒ±zƒ±
                        const legSwing = Math.sin(time * walkSpeed) * 0.3; // Bacak sallanma miktarƒ±
                        
                        // Sol bacak
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        if (leftLeg) {
                            leftLeg.rotation.x = legSwing;
                        }
                        
                        // Saƒü bacak
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        if (rightLeg) {
                            rightLeg.rotation.x = -legSwing; // Ters y√∂nde hareket
                        }
                        
                        // Kollarƒ± da hafif√ße salla
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftArm) leftArm.rotation.x = -legSwing * 0.5;
                        if (rightArm) rightArm.rotation.x = legSwing * 0.5;
                        
                        // Hafif yukarƒ±-a≈üaƒüƒ± hareket (adƒ±m atma efekti)
                        player.position.y = Math.abs(Math.sin(time * walkSpeed)) * 0.1;
                        
                        // Karakteri hareket y√∂n√ºne g√∂re d√∂nd√ºr
                        let targetRotation = 0;
                        
                        if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                            // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                            targetRotation = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ±
                        } else if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                            // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                            targetRotation = Math.atan2(-15, 15) + Math.PI;
                        } else if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                            // Sol - kameranƒ±n soluna doƒüru
                            targetRotation = Math.atan2(-15, 15) + Math.PI / 2;
                        } else if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                            // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                            targetRotation = Math.atan2(-15, 15) - Math.PI / 2;
                        }
                        
                        // Joystick i√ßin de d√∂nd√ºrme
                        if (Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1) {
                            targetRotation = Math.atan2(-this.movement.joystick.y, this.movement.joystick.x) + Math.atan2(-15, 15);
                        }
                        
                        // Yumu≈üak d√∂nd√ºrme
                        const rotationSpeed = 0.1;
                        const currentRotation = player.rotation.y;
                        const rotationDiff = targetRotation - currentRotation;
                        
                        // En kƒ±sa yolu bul (180 derece √ºzerinden d√∂nmemek i√ßin)
                        let shortestRotation = rotationDiff;
                        if (rotationDiff > Math.PI) shortestRotation -= 2 * Math.PI;
                        if (rotationDiff < -Math.PI) shortestRotation += 2 * Math.PI;
                        
                        player.rotation.y += shortestRotation * rotationSpeed;
                    } else {
                        // Durduƒüunda bacaklarƒ± d√ºzelt
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftLeg) leftLeg.rotation.x = 0;
                        if (rightLeg) rightLeg.rotation.x = 0;
                        if (leftArm) leftArm.rotation.x = 0;
                        if (rightArm) rightArm.rotation.x = 0;
                        
                        // Y pozisyonunu sƒ±fƒ±rla
                        player.position.y = 0;
                    }
                }

                // Kar animasyonu
                if (this.sceneObjects.snowSystem) {
                    const positions = this.sceneObjects.snowSystem.geometry.attributes.position.array;
                    const velocities = this.sceneObjects.snowSystem.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= velocities[i / 3] * this.gameState.stormIntensity * 0.01;
                        positions[i] += Math.sin(time + i) * 0.005 * this.gameState.stormIntensity;
                        
                        if (positions[i + 1] < -5) {
                            positions[i + 1] = 50;
                            positions[i] = (Math.random() - 0.5) * 100;
                            positions[i + 2] = (Math.random() - 0.5) * 100;
                        }
                    }
                    this.sceneObjects.snowSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Hayatta kalanlarƒ± animasyonla
                this.sceneObjects.survivors.forEach((survivor, index) => {
                    survivor.rotation.y += 0.01;
                    survivor.position.y = 0.75 + Math.sin(time * 2 + index) * 0.1;
                });
            }

            render() {
                // Three.js sahneyi render et - t√ºm objeleri her zaman render et
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // T√ºm objeleri g√∂r√ºn√ºr yap
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
                
                this.renderer.clear();
                this.renderer.render(this.scene, this.camera);
            }


            resourceDecayLoop() {
                if (this.gameState.isGameOver) return;

                // Kaynaklarƒ± azalt
                const heatDecay = 2 * this.gameState.stormIntensity;
                const foodDecay = 1 + (this.gameState.survivors * 0.5);
                
                this.gameState.heat = Math.max(0, this.gameState.heat - heatDecay);
                this.gameState.food = Math.max(0, this.gameState.food - foodDecay);
                
                this.updateUI();
                
                setTimeout(() => this.resourceDecayLoop(), 1000);
            }

            updateUI() {
                // Skor
                document.getElementById('scoreDisplay').textContent = `Skor: ${this.gameState.score}`;
                
                // Kaynaklar
                document.getElementById('heatBar').style.width = `${this.gameState.heat}%`;
                document.getElementById('foodBar').style.width = `${this.gameState.food}%`;
                document.getElementById('shelterBar').style.width = `${this.gameState.shelter}%`;
            }

            checkGameOver() {
                if (this.gameState.heat <= 0 || this.gameState.food <= 0) {
                    this.gameOver();
                }
            }

            gameOver() {
                this.gameState.isGameOver = true;
                // Se√ßim sistemi kaldƒ±rƒ±ldƒ±
                
                // Final skoru
                const finalScore = this.gameState.score + this.gameState.survivors * 5 + this.gameState.day;
                
                document.getElementById('finalScore').textContent = `Final Skor: ${finalScore}`;
                document.getElementById('gameOverScreen').classList.add('show');
                
                // Farcade'e bildir
                Farcade.gameOver({ score: finalScore });
            }

            restartGame() {
                // Oyun durumunu sƒ±fƒ±rla
                this.gameState = {
                    heat: 100,
                    food: 100,
                    shelter: 100,
                    survivors: 1,
                    day: 1,
                    score: 0,
                    isGameOver: false,
                    stormIntensity: 1,
                    lastStormIncrease: Date.now()
                };

                // UI'ƒ± sƒ±fƒ±rla
                this.updateUI();
                document.getElementById('gameOverScreen').classList.remove('show');
                // Se√ßim sistemi kaldƒ±rƒ±ldƒ±

                // Oyunu yeniden ba≈ülat
                this.startGame();
            }
        }

        // Oyunu ba≈ülat
        window.addEventListener('load', () => {
            new ColdHorizon3D();
        });

        // Farcade SDK event listeners
        window.addEventListener('play_again', () => {
            location.reload();
        });

        window.addEventListener('toggle_mute', () => {
            // Ses kontrol√º (≈üu anda ses yok)
            console.log('Ses a√ßƒ±k/kapalƒ±');
        });
    </script>
</body>
</html>
