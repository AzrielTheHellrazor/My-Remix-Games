<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cold Horizon 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            background: linear-gradient(180deg, #0a1929 0%, #1e3a5f 50%, #2d5aa0 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            height: 750px;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            border: 2px solid #334155;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }

        #gameCanvas {
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .top-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .score {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            color: #fbbf24;
            border: 2px solid #f59e0b;
        }

        .resources {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 15px;
            min-width: 120px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            font-size: 16px;
        }

        .resource-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .resource-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .heat-fill { background: linear-gradient(90deg, #f97316 0%, #ea580c 100%); }
        .food-fill { background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%); }
        .shelter-fill { background: linear-gradient(90deg, #3b82f6 0%, #2563eb 100%); }

        /* Tycoon UI */
        .tycoon-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            min-width: 200px;
            color: white;
            font-weight: bold;
        }

        .money-display {
            font-size: 18px;
            color: #10b981;
            margin-bottom: 5px;
        }

        .income-display {
            font-size: 14px;
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .upgrade-info {
            font-size: 12px;
            color: #94a3b8;
            text-align: center;
            border-top: 1px solid #374151;
            padding-top: 8px;
        }


        /* Mobil Joystick */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .mobile-controls.show {
            opacity: 1;
            visibility: visible;
            pointer-events: all;
        }

        .joystick {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #3b82f6;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: 2px solid #ffffff;
            position: absolute;
            cursor: grab;
            transition: transform 0.1s ease;
        }

        .joystick-knob:active {
            cursor: grabbing;
        }

        /* Klavye kontrolleri g√∂stergesi ve Minimap kaldƒ±rƒ±ldƒ± */


        @media (max-width: 520px) {
            .game-container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                border: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Three.js CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <!-- Farcade SDK -->
        <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
        
        <div class="ui-overlay">
            <!-- Tycoon UI -->
            <div class="tycoon-ui" id="tycoonUI">
                <div class="money-display" id="moneyDisplay">üí∞ $500</div>
                <div class="income-display" id="incomeDisplay">üìà +$0/sec</div>
                <div class="upgrade-info" id="upgradeInfo">
                    üè≠ Step on platforms to buy upgrades!
                </div>
            </div>
            
            <div class="top-ui">
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: space-between; width: 100%;">
                    <!-- Sol taraf: Score ve Time -->
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="score" id="scoreDisplay">Score: 0</div>
                        <div class="time-counter" style="background: rgba(0, 0, 0, 0.7); padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 14px; color: #10b981; border: 2px solid #059669;" id="timeCounter">‚è±Ô∏è Time: 0:00</div>
                    </div>
                    
                    <!-- Saƒü taraf: Health bar -->
                    <div class="health-bar" style="width: 120px; height: 20px; background: rgba(0, 0, 0, 0.7); border-radius: 10px; border: 2px solid #ef4444; overflow: hidden; position: relative;">
                        <div class="health-fill" id="healthFill" style="height: 100%; background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%); width: 100%; transition: width 0.3s ease;"></div>
                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);" id="healthText">‚ù§Ô∏è 100/100</div>
                    </div>
                </div>
                
                <!-- Crosshair kaldƒ±rƒ±ldƒ± - hareket y√∂n√º ni≈üan sistemi -->
                
                <!-- Resource bars removed - tycoon only -->
            </div>


            <!-- Mobil Joystick -->
            <div class="mobile-controls" id="mobileControls">
                <div class="joystick">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>

            <!-- Klavye kontrol√º g√∂stergesi ve minimap kaldƒ±rƒ±ldƒ± -->
        </div>
    </div>

    <script>
        // Farcade SDK Integration

        class ColdHorizon3D {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                
                // Canvas boyutlarƒ±nƒ± ayarla
                this.setupCanvas();
                
                // Three.js sahne olu≈ütur
                this.initThreeJS();
                
                // Basit oyun durumu
                this.gameState = {
                    score: 0,
                    totalEarned: 0, // Total money earned (never decreases)
                    isGameOver: false,
                    gameWon: false,
                    spaceCount: 0, // Space key press counter
                    gears: 0, // Collected gears for repairs
                    lastBreakdownTime: 0,
                    brokenMachines: [], // IDs of broken machines
                    startTime: Date.now(), // Game start time for speed bonus
                    timeBonus: 0, // Bonus points for completing fast
                    timeLimit: 210, // 3:30 in seconds
                    gameEnded: false,
                    // Zombi sistemi
                    health: 100, // Oyuncu canƒ±
                    maxHealth: 100,
                    zombiesKilled: 0, // √ñld√ºr√ºlen zombi sayƒ±sƒ±
                    lastZombieSpawn: 0, // Son zombi spawn zamanƒ±
                    zombieSpawnRate: 5000, // 5 saniyede bir zombi spawn
                    combatMode: false, // Sava≈ü modu aktif mi
                    lastAttack: 0, // Son saldƒ±rƒ± zamanƒ±
                    // Silah sistemi
                    weapon: {
                        type: 'pistol',
                        damage: 35,
                        range: 15, // 15 metre menzil
                        fireRate: 500, // 0.5 saniye cooldown
                        lastFired: 0,
                        ammo: 999, // Sƒ±nƒ±rsƒ±z mermi
                        recoil: 0.1
                    },
                    // Hareket y√∂n√º ni≈üan sistemi
                    aiming: {
                        aimDirection: { x: 0, z: -1 }, // Varsayƒ±lan olarak √∂ne bakƒ±yor
                        lastMoveDirection: { x: 0, z: -1 } // Son hareket y√∂n√º
                    }
                };

                // Yeni Tycoon Sistemi
                this.tycoon = {
                    money: 500, // Ba≈ülangƒ±√ß parasƒ± artƒ±rƒ±ldƒ±
                    moneyPerSecond: 0,
                    lastIncomeTime: Date.now(),
                    level: 0,
                    upgrades: [
                        {
                            id: 1,
                            name: 'Storage Area',
                            description: 'Basic storage facility',
                            cost: 200,
                            income: 20,
                            bought: false,
                            position: { x: -8, z: 6 },
                            objects: []
                        },
                        {
                            id: 2,
                            name: 'Production Machine',
                            description: 'Automated production',
                            cost: 600,
                            income: 50,
                            bought: false,
                            position: { x: -4, z: 6 },
                            objects: [],
                            requires: 1
                        },
                        {
                            id: 3,
                            name: 'Conveyor Belt',
                            description: 'Transports products',
                            cost: 1200,
                            income: 80,
                            bought: false,
                            position: { x: 0, z: 6 },
                            objects: [],
                            requires: 2
                        },
                        {
                            id: 4,
                            name: 'Packaging Unit',
                            description: 'Packages products',
                            cost: 2000,
                            income: 120,
                            bought: false,
                            position: { x: 4, z: 6 },
                            objects: [],
                            requires: 3
                        },
                        {
                            id: 5,
                            name: 'Shipping Center',
                            description: 'Ships products',
                            cost: 3500,
                            income: 180,
                            bought: false,
                            position: { x: 8, z: 6 },
                            objects: [],
                            requires: 4
                        },
                        {
                            id: 6,
                            name: 'Quality Control',
                            description: 'Improves quality',
                            cost: 6000,
                            income: 250,
                            bought: false,
                            position: { x: 8, z: 2 },
                            objects: [],
                            requires: 5
                        },
                        {
                            id: 7,
                            name: 'R&D Center',
                            description: 'New technologies',
                            cost: 10000,
                            income: 400,
                            bought: false,
                            position: { x: 4, z: 2 },
                            objects: [],
                            requires: 6
                        },
                        {
                            id: 8,
                            name: 'Automation System',
                            description: 'Fully automated production',
                            cost: 15000,
                            income: 600,
                            bought: false,
                            position: { x: 0, z: 2 },
                            objects: [],
                            requires: 7
                        }
                    ]
                };

                // 3D objeler
                this.sceneObjects = {
                    shelter: null,
                    fire: null,
                    survivors: [],
                    snowSystem: null,
                    player: null,
                    roads: [],
                    houses: [],
                    world: null,
                    tycoonPlatforms: [],
                    tycoonObjects: [],
                    gears: [], // Collectible gears on ground
                    zombies: [] // Zombi d√º≈ümanlar
                };

                // Hareket sistemi
                this.movement = {
                    keys: {
                        w: false, a: false, s: false, d: false,
                        ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false,
                        space: false
                    },
                    speed: 0.3,
                    joystick: { x: 0, y: 0 },
                    // Zƒ±plama sistemi kaldƒ±rƒ±ldƒ± - silah sistemi kullanƒ±lƒ±yor
                    weaponAiming: false // Silah ni≈üan alma durumu
                };

                // Harita sistemi
                this.worldMap = {
                    width: 100,
                    height: 100,
                    playerPosition: { x: 0, y: 0, z: 0 }
                };

                // Minimap kaldƒ±rƒ±ldƒ±
                

                // Event listeners
                this.setupEventListeners();
                
                // 3D sahneyi olu≈ütur
                this.create3DScene();
                
                // Zombi sistemini ba≈ülat
                this.initZombieSystem();
                
                // Oyunu ba≈ülat
                this.startGame();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                this.width = rect.width;
                this.height = rect.height;
            }

            initThreeJS() {
                // Sahne olu≈ütur
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x0f172a, 50, 200);

                // Kamera olu≈ütur (perspektif kamera)
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    this.width / this.height, 
                    0.1, 
                    1000
                );
                // Kamerayƒ± Y ekseni sabit kalacak ≈üekilde ters y√∂nde d√∂nd√ºr (yakƒ±nla≈ütƒ±rƒ±lmƒ±≈ü)
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // Kamera frustum ayarlarƒ±
                this.camera.far = 1000;
                this.camera.near = 0.1;
                
                // Kamerayƒ± tamamen sabitle
                this.camera.position.x = -15;
                this.camera.position.y = 20;
                this.camera.position.z = 15;

                // Renderer olu≈ütur
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true,
                    alpha: false,
                    logarithmicDepthBuffer: false
                });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = false; // G√∂lgeleri kapat
                this.renderer.setClearColor(0x0f172a, 1);
                
                // Render optimizasyonlarƒ±nƒ± kapat
                this.renderer.sortObjects = false;
                this.renderer.autoClear = true;
                
                // Frustum culling'i tamamen kapat
                this.renderer.setClearColor(0x0f172a, 1);
                this.scene.autoUpdate = true;

                // I≈üƒ±klandƒ±rma
                this.setupLighting();

                // Kamera kontrolleri
                this.setupCameraControls();
            }

            setupLighting() {
                // Ambient ƒ±≈üƒ±k (genel aydƒ±nlatma)
                const ambientLight = new THREE.AmbientLight(0x334155, 0.3);
                this.scene.add(ambientLight);

                // Direkt ƒ±≈üƒ±k (g√ºne≈ü)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Ate≈ü ƒ±≈üƒ±ƒüƒ± (point light)
                this.fireLight = new THREE.PointLight(0xf97316, 2, 15);
                this.fireLight.position.set(0, 2, 0);
                this.fireLight.castShadow = true;
                this.scene.add(this.fireLight);
            }

            setupCameraControls() {
                // Kamera tamamen sabit - hi√ßbir kontrol yok
            }

            setupEventListeners() {
                // Klavye kontrolleri
                document.addEventListener('keydown', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = true;
                        e.preventDefault();
                    }
                    
                    // Space key for shooting zombies
                    if (e.key === ' ' || e.code === 'Space') {
                        this.movement.keys.space = true;
                        this.gameState.spaceCount++;
                        this.shootWeapon(); // Silah ate≈üle
                        console.log(`Weapon fired! Count: ${this.gameState.spaceCount}`);
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (this.movement.keys.hasOwnProperty(e.key)) {
                        this.movement.keys[e.key] = false;
                        e.preventDefault();
                    }
                    
                    // Space key release
                    if (e.key === ' ' || e.code === 'Space') {
                        this.movement.keys.space = false;
                        e.preventDefault();
                    }
                });

                // Dokunmatik kontroller (artƒ±k sadece joystick i√ßin)

                // Mobil joystick
                this.setupJoystick();

                // Mouse sistemi kaldƒ±rƒ±ldƒ± - hareket y√∂n√º ni≈üan sistemi

                // Mobil kontrolleri g√∂ster/gizle
                this.detectMobile();

                // Resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                });
            }

            detectMobile() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const mobileControls = document.getElementById('mobileControls');
                
                if (isMobile) {
                    mobileControls.classList.add('show');
                } else {
                    mobileControls.classList.remove('show');
                }
            }

            setupJoystick() {
                const joystick = document.getElementById('joystickKnob');
                let isDragging = false;
                let startPos = { x: 0, y: 0 };

                joystick.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                joystick.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    
                    const touch = e.touches[0];
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                    
                    e.preventDefault();
                });

                joystick.addEventListener('touchend', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });

                // Mouse desteƒüi (masa√ºst√º test i√ßin)
                joystick.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = joystick.parentElement.getBoundingClientRect();
                    startPos.x = rect.left + rect.width / 2;
                    startPos.y = rect.top + rect.height / 2;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const rect = joystick.parentElement.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = e.clientX - centerX;
                    const deltaY = e.clientY - centerY;
                    
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 20;
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const newX = Math.cos(angle) * maxDistance;
                        const newY = Math.sin(angle) * maxDistance;
                        joystick.style.transform = `translate(${newX}px, ${newY}px)`;
                        
                        this.movement.joystick.x = newX / maxDistance;
                        this.movement.joystick.y = newY / maxDistance;
                    } else {
                        joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        
                        this.movement.joystick.x = deltaX / maxDistance;
                        this.movement.joystick.y = deltaY / maxDistance;
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    joystick.style.transform = 'translate(0, 0)';
                    this.movement.joystick.x = 0;
                    this.movement.joystick.y = 0;
                });
            }

            // Mouse sistemi tamamen kaldƒ±rƒ±ldƒ± - hareket y√∂n√º ni≈üan sistemi kullanƒ±lƒ±yor

            // setupMinimap fonksiyonu kaldƒ±rƒ±ldƒ± - zƒ±plama sistemi kaldƒ±rƒ±ldƒ±

            create3DScene() {
                this.createWorld();
                this.createPlayer();
                this.createTycoonPlatforms();
                this.spawnInitialGears();
                this.createSnowSystem();
                
                // T√ºm objeleri ba≈ütan render et
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
            }

            createWorld() {
                // T√ºm harita ba≈ütan y√ºklensin - b√ºy√ºk d√ºnya zemini
                const groundGeometry = new THREE.PlaneGeometry(this.worldMap.width, this.worldMap.height);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1e293b,
                    transparent: false,
                    opacity: 1.0
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                ground.frustumCulled = false; // T√ºm harita her zaman g√∂r√ºn√ºr
                ground.visible = true;
                this.scene.add(ground);

                // T√ºm kar zemini y√ºklensin
                const snowGeometry = new THREE.PlaneGeometry(this.worldMap.width + 20, this.worldMap.height + 20);
                const snowMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf8fafc,
                    transparent: true,
                    opacity: 0.6
                });
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                snow.rotation.x = -Math.PI / 2;
                snow.position.y = 0.01;
                snow.frustumCulled = false; // T√ºm kar zemini her zaman g√∂r√ºn√ºr
                snow.visible = true;
                this.scene.add(snow);

                // D√ºnya sƒ±nƒ±rlarƒ± (g√∂r√ºnmez duvarlar)
                this.createWorldBounds();

                this.sceneObjects.world = { ground, snow };
            }

            createWorldBounds() {
                // D√ºnya sƒ±nƒ±rlarƒ± i√ßin g√∂r√ºnmez duvarlar
                const bounds = [
                    { pos: [0, 25, this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // Arka
                    { pos: [0, 25, -this.worldMap.height/2], size: [2, 50, this.worldMap.height] }, // √ñn
                    { pos: [this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }, // Saƒü
                    { pos: [-this.worldMap.width/2, 25, 0], size: [this.worldMap.width, 50, 2] }  // Sol
                ];

                bounds.forEach(bound => {
                    const geometry = new THREE.BoxGeometry(bound.size[0], bound.size[1], bound.size[2]);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0 
                    });
                    const wall = new THREE.Mesh(geometry, material);
                    wall.position.set(bound.pos[0], bound.pos[1], bound.pos[2]);
                    wall.userData = { isBoundary: true };
                    wall.frustumCulled = false; // Frustum culling'i devre dƒ±≈üƒ± bƒ±rak
                    this.scene.add(wall);
                });
            }

            // Tycoon platformlarƒ± kaldƒ±rƒ±ldƒ±

            spawnInitialGears() {
                // Initial gears scattered around the map
                for (let i = 0; i < 10; i++) {
                    this.spawnGear();
                }
            }
            
            spawnGear() {
                // Create gear geometry
                const gearGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
                const gearMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffd700, // Gold
                    emissive: 0x332200
                });
                const gear = new THREE.Mesh(gearGeometry, gearMaterial);
                
                // Random position on the map
                const x = (Math.random() - 0.5) * 30; // Within reasonable range
                const z = (Math.random() - 0.5) * 30;
                gear.position.set(x, 0.2, z);
                
                // Add rotation animation
                gear.userData = { 
                    type: 'gear',
                    rotationSpeed: Math.random() * 0.02 + 0.01
                };
                
                gear.castShadow = true;
                gear.frustumCulled = false;
                
                this.scene.add(gear);
                this.sceneObjects.gears.push(gear);
                
                console.log(`Gear spawned at (${x.toFixed(1)}, ${z.toFixed(1)})`);
            }

            // Zombi Sistemi
            initZombieSystem() {
                console.log("Zombi sistemi ba≈ülatƒ±lƒ±yor...");
                this.gameState.lastZombieSpawn = Date.now();
            }

            createZombie() {
                console.log("Yeni zombi olu≈üturuluyor...");
                
                // Zombi karakteri olu≈ütur
                const zombie = new THREE.Group();
                
                // V√ºcut (ana g√∂vde) - zombi i√ßin daha karanlƒ±k renkler
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.7, 2.2, 6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2d4a22 }); // Koyu ye≈üil
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.1;
                body.castShadow = true;
                zombie.add(body);

                // Kafa - zombi kafasƒ±
                const headGeometry = new THREE.SphereGeometry(0.45, 6, 5);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0x8b956d }); // Soluk ye≈üil
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.8;
                head.castShadow = true;
                zombie.add(head);

                // G√∂zler - kƒ±rmƒ±zƒ± parlayan g√∂zler
                const eyeGeometry = new THREE.SphereGeometry(0.08, 4, 3);
                const eyeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff0000,
                    emissive: 0x440000
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 2.9, 0.35);
                zombie.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.15, 2.9, 0.35);
                zombie.add(rightEye);

                // Kollar - zombi kollarƒ±
                const leftArmGeometry = new THREE.CylinderGeometry(0.14, 0.18, 1.4, 5);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8b956d });
                const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
                leftArm.position.set(-0.7, 1.4, 0);
                leftArm.rotation.z = 0.5; // Zombi gibi sarkƒ±k kol
                leftArm.castShadow = true;
                zombie.add(leftArm);

                const rightArmGeometry = new THREE.CylinderGeometry(0.14, 0.18, 1.4, 5);
                const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
                rightArm.position.set(0.7, 1.4, 0);
                rightArm.rotation.z = -0.5; // Zombi gibi sarkƒ±k kol
                rightArm.castShadow = true;
                zombie.add(rightArm);

                // Bacaklar - zombi bacaklarƒ±
                const leftLegGeometry = new THREE.CylinderGeometry(0.18, 0.22, 1.8, 5);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const leftLeg = new THREE.Mesh(leftLegGeometry, legMaterial);
                leftLeg.position.set(-0.25, -0.9, 0);
                leftLeg.castShadow = true;
                zombie.add(leftLeg);

                const rightLegGeometry = new THREE.CylinderGeometry(0.18, 0.22, 1.8, 5);
                const rightLeg = new THREE.Mesh(rightLegGeometry, legMaterial);
                rightLeg.position.set(0.25, -0.9, 0);
                rightLeg.castShadow = true;
                zombie.add(rightLeg);

                // Harita kenarƒ±ndan rastgele spawn
                const spawnDistance = 25; // Oyuncudan uzak spawn
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * spawnDistance;
                const z = Math.sin(angle) * spawnDistance;
                
                zombie.position.set(x, 2.8, z);
                
                // Zombi √∂zellikleri
                zombie.userData = {
                    type: 'zombie',
                    health: 30,
                    maxHealth: 30,
                    speed: 0.08, // Oyuncudan yava≈ü
                    damage: 15,
                    lastAttack: 0,
                    attackCooldown: 2000, // 2 saniye
                    target: null, // Hedef (oyuncu)
                    state: 'hunting', // hunting, attacking, dead
                    deathTime: 0
                };
                
                zombie.castShadow = true;
                zombie.frustumCulled = false;
                
                this.scene.add(zombie);
                this.sceneObjects.zombies.push(zombie);
                
                console.log(`Zombi spawn edildi: (${x.toFixed(1)}, ${z.toFixed(1)})`);
                return zombie;
            }

            spawnZombie() {
                const now = Date.now();
                
                // Spawn rate kontrol√º
                if (now - this.gameState.lastZombieSpawn < this.gameState.zombieSpawnRate) {
                    return;
                }
                
                // Maksimum zombi sayƒ±sƒ± kontrol√º (performans i√ßin)
                if (this.sceneObjects.zombies.length >= 8) {
                    return;
                }
                
                this.createZombie();
                this.gameState.lastZombieSpawn = now;
                
                // Zamanla spawn rate'i artƒ±r
                if (this.gameState.zombieSpawnRate > 2000) {
                    this.gameState.zombieSpawnRate -= 50;
                }
            }
            
            // Tycoon baƒülantƒ± fonksiyonlarƒ± kaldƒ±rƒ±ldƒ±

            createTycoonPlatforms() {
                console.log("Yeni tycoon platformlarƒ± olu≈üturuluyor...");
                
                this.tycoon.upgrades.forEach(upgrade => {
                    // Platform olu≈ütur
                    const platformGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 16);
                    let platformColor = 0x6b7280; // Gri - kilitli
                    
                    if (upgrade.bought) {
                        platformColor = 0x10b981; // Ye≈üil - satƒ±n alƒ±nmƒ±≈ü
                    } else if (this.canBuyUpgrade(upgrade)) {
                        platformColor = 0xf59e0b; // Sarƒ± - satƒ±n alƒ±nabilir
                    }
                    
                    const platformMaterial = new THREE.MeshLambertMaterial({ 
                        color: platformColor,
                        transparent: false
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    
                    platform.position.set(upgrade.position.x, 0.15, upgrade.position.z);
                    platform.userData = { 
                        type: 'tycoonPlatform',
                        upgradeId: upgrade.id,
                        upgrade: upgrade
                    };
                    
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    platform.frustumCulled = false;
                    
                    this.scene.add(platform);
                    this.sceneObjects.tycoonPlatforms.push(platform);
                    
                    // Platform √ºzerinde bilgi etiketi
                    if (!upgrade.bought) {
                        this.createUpgradeInfo(upgrade);
                    }
                    
                    console.log(`Platform olu≈üturuldu: ${upgrade.name} - $${upgrade.cost}`);
                });
                
                console.log(`Toplam ${this.sceneObjects.tycoonPlatforms.length} tycoon platformu olu≈üturuldu`);
            }
            
            createUpgradeInfo(upgrade) {
                // Bilgi etiketi
                const labelGeometry = new THREE.BoxGeometry(3, 0.8, 0.1);
                let labelColor = 0x1f2937;
                
                if (!this.canBuyUpgrade(upgrade)) {
                    labelColor = 0x7f1d1d; // Kƒ±rmƒ±zƒ± - kilitli
                }
                
                const labelMaterial = new THREE.MeshLambertMaterial({ 
                    color: labelColor,
                    transparent: true,
                    opacity: 0.9
                });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                
                label.position.set(upgrade.position.x, 2.5, upgrade.position.z + 1);
                label.userData = { 
                    type: 'upgradeInfo',
                    upgradeId: upgrade.id
                };
                
                this.scene.add(label);
                this.sceneObjects.tycoonObjects.push(label);
            }
            
            canBuyUpgrade(upgrade) {
                // Para kontrol√º
                if (this.tycoon.money < upgrade.cost) {
                    return false;
                }
                
                // Gereksinim kontrol√º
                if (upgrade.requires) {
                    const requiredUpgrade = this.tycoon.upgrades.find(u => u.id === upgrade.requires);
                    if (!requiredUpgrade || !requiredUpgrade.bought) {
                        return false;
                    }
                }
                
                return true;
            }

            createPlayer() {
                // ƒ∞nsan ≈üeklinde oyuncu karakteri olu≈ütur
                const player = new THREE.Group();
                
                // V√ºcut (ana g√∂vde) - daha b√ºy√ºk
                const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.4, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3b82f6 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.2;
                body.castShadow = true;
                player.add(body);

                // Kafa - daha b√ºy√ºk
                const headGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 3.0;
                head.castShadow = true;
                player.add(head);

                // Sa√ß - daha b√ºy√ºk
                const hairGeometry = new THREE.SphereGeometry(0.54, 8, 6);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 3.1;
                hair.scale.y = 0.7;
                player.add(hair);

                // Sol kol - daha b√ºy√ºk
                const leftArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
                leftArm.position.set(-0.8, 1.6, 0);
                leftArm.rotation.z = 0.3;
                leftArm.castShadow = true;
                player.add(leftArm);

                // Saƒü kol - daha b√ºy√ºk
                const rightArmGeometry = new THREE.CylinderGeometry(0.16, 0.2, 1.6, 6);
                const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
                rightArm.position.set(0.8, 1.6, 0);
                rightArm.rotation.z = -0.3;
                rightArm.castShadow = true;
                player.add(rightArm);

                // Sol bacak - daha b√ºy√ºk
                const leftLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
                const leftLeg = new THREE.Mesh(leftLegGeometry, legMaterial);
                leftLeg.position.set(-0.3, -1.0, 0);
                leftLeg.castShadow = true;
                player.add(leftLeg);

                // Saƒü bacak - daha b√ºy√ºk
                const rightLegGeometry = new THREE.CylinderGeometry(0.2, 0.24, 2.0, 6);
                const rightLeg = new THREE.Mesh(rightLegGeometry, legMaterial);
                rightLeg.position.set(0.3, -1.0, 0);
                rightLeg.castShadow = true;
                player.add(rightLeg);

                // Ayaklar - daha b√ºy√ºk
                const footGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.8);
                const footMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                
                const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                leftFoot.position.set(-0.3, -2.1, 0.2);
                leftFoot.castShadow = true;
                player.add(leftFoot);

                const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                rightFoot.position.set(0.3, -2.1, 0.2);
                rightFoot.castShadow = true;
                player.add(rightFoot);

                // Silah ekle - saƒü elde pistol
                const weaponGroup = this.createWeapon();
                weaponGroup.position.set(0.8, 1.2, 0.3); // Saƒü el pozisyonu
                weaponGroup.rotation.set(0, 0, -0.2); // Hafif eƒüim
                player.add(weaponGroup);

                // Oyuncuyu sahneye ekle - ba≈ülangƒ±√ß pozisyonu 0,3,0 (ayaklar tamamen yerin √ºst√ºnde)
                player.position.set(0, 3, 0);
                // Karakteri 180 derece d√∂nd√ºr
                player.rotation.y = Math.PI;
                this.scene.add(player);

                this.sceneObjects.player = player;
            }

            createWeapon() {
                // Pistol silahƒ± olu≈ütur
                const weaponGroup = new THREE.Group();
                
                // Silah g√∂vdesi (ana kƒ±sƒ±m)
                const bodyGeometry = new THREE.BoxGeometry(0.15, 0.6, 0.08);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c }); // Koyu gri
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0, 0);
                body.castShadow = true;
                weaponGroup.add(body);

                // Namlu
                const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8);
                const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a }); // Siyah
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(0, 0.35, 0);
                barrel.rotation.z = Math.PI / 2; // Yatay
                barrel.castShadow = true;
                weaponGroup.add(barrel);

                // Kabza (tutma yeri)
                const gripGeometry = new THREE.BoxGeometry(0.12, 0.3, 0.06);
                const gripMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 }); // Kahverengi
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.position.set(0, -0.25, 0);
                grip.castShadow = true;
                weaponGroup.add(grip);

                // Ni≈üangah
                const sightGeometry = new THREE.BoxGeometry(0.03, 0.05, 0.02);
                const sightMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 }); // Altƒ±n
                const sight = new THREE.Mesh(sightGeometry, sightMaterial);
                sight.position.set(0, 0.25, 0.05);
                weaponGroup.add(sight);

                weaponGroup.userData = { type: 'weapon', weaponType: 'pistol' };
                return weaponGroup;
            }

            shootWeapon() {
                const now = Date.now();
                const weapon = this.gameState.weapon;
                
                // Fire rate kontrol√º
                if (now - weapon.lastFired < weapon.fireRate) {
                    return;
                }
                
                weapon.lastFired = now;
                
                // Silah ate≈üleme efekti
                this.playWeaponFireEffect();
                
                // En yakƒ±n zombiyi hedefle ve vur
                this.shootAtNearestZombie();
                
                console.log(`Silah ate≈ülendi! Hasar: ${weapon.damage}, Menzil: ${weapon.range}m`);
            }

            playWeaponFireEffect() {
                if (!this.sceneObjects.player) return;
                
                // Silahƒ± bul
                const weapon = this.sceneObjects.player.children.find(child => 
                    child.userData && child.userData.type === 'weapon'
                );
                
                if (!weapon) return;
                
                // Recoil animasyonu
                const originalRotation = weapon.rotation.x;
                weapon.rotation.x -= this.gameState.weapon.recoil;
                
                setTimeout(() => {
                    weapon.rotation.x = originalRotation;
                }, 100);
                
                // Muzzle flash efekti (namlu alevi)
                this.createMuzzleFlash(weapon);
                
                // Haptic feedback
                if (window.FarcadeSDK && window.FarcadeSDK.singlePlayer.actions.hapticFeedback) {
                    window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
                }
            }

            createMuzzleFlash(weapon) {
                // Namlu alevi efekti
                const flashGeometry = new THREE.SphereGeometry(0.1, 6, 4);
                const flashMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                
                // Namlu ucuna yerle≈ütir
                flash.position.set(0, 0.5, 0);
                weapon.add(flash);
                
                // Kƒ±sa s√ºre sonra kaldƒ±r
                setTimeout(() => {
                    weapon.remove(flash);
                }, 50);
            }

            shootAtNearestZombie() {
                const weapon = this.gameState.weapon;
                const aimDir = this.gameState.aiming.aimDirection;
                
                // Raycast ile bakƒ±≈ü y√∂n√ºndeki zombileri bul
                const hitZombies = this.raycastZombies(aimDir, weapon.range);
                
                if (hitZombies.length > 0) {
                    // En yakƒ±n zombiyi vur
                    const nearestHit = hitZombies[0];
                    this.damageZombie(nearestHit.zombie, nearestHit.index, weapon.damage);
                    
                    // Mermi izi efekti - vurulan zombiye
                    this.createBulletTrail(nearestHit.zombie.position);
                } else {
                    // Bo≈üa ate≈ü - sadece mermi izi g√∂ster
                    const endPoint = {
                        x: aimDir.x * weapon.range,
                        y: 3,
                        z: aimDir.z * weapon.range
                    };
                    this.createBulletTrail(endPoint);
                }
            }

            raycastZombies(direction, maxRange) {
                const hitZombies = [];
                const rayOrigin = { x: 0, y: 3, z: 0 }; // Oyuncu pozisyonu
                
                for (let i = 0; i < this.sceneObjects.zombies.length; i++) {
                    const zombie = this.sceneObjects.zombies[i];
                    
                    if (!zombie || !zombie.userData || zombie.userData.state === 'dead') continue;
                    
                    // Zombiye olan vekt√∂r
                    const toZombie = {
                        x: zombie.position.x - rayOrigin.x,
                        y: zombie.position.y - rayOrigin.y,
                        z: zombie.position.z - rayOrigin.z
                    };
                    
                    // Mesafe kontrol√º
                    const distance = Math.sqrt(toZombie.x * toZombie.x + toZombie.z * toZombie.z);
                    if (distance > maxRange) continue;
                    
                    // Y√∂n vekt√∂r√ºn√º normalize et
                    const zombieDirection = {
                        x: toZombie.x / distance,
                        z: toZombie.z / distance
                    };
                    
                    // Ni≈üan y√∂n√º ile zombi y√∂n√º arasƒ±ndaki a√ßƒ±
                    const dotProduct = direction.x * zombieDirection.x + direction.z * zombieDirection.z;
                    const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
                    
                    // A√ßƒ± toleransƒ± (yakla≈üƒ±k 30 derece)
                    const angleThreshold = Math.PI / 6; // 30 derece
                    
                    if (angle <= angleThreshold) {
                        hitZombies.push({
                            zombie: zombie,
                            index: i,
                            distance: distance,
                            angle: angle
                        });
                    }
                }
                
                // Mesafeye g√∂re sƒ±rala (en yakƒ±n √∂nce)
                hitZombies.sort((a, b) => a.distance - b.distance);
                
                return hitZombies;
            }

            damageZombie(zombie, index, damage) {
                if (!zombie || !zombie.userData) return;
                
                zombie.userData.health -= damage;
                
                // Zombi √∂ld√º m√º?
                if (zombie.userData.health <= 0) {
                    this.killZombie(zombie, index);
                } else {
                    // Hasar efekti - zombiyi kƒ±rmƒ±zƒ±ya boyar
                    this.showZombieDamageEffect(zombie);
                }
                
                console.log(`Zombi vuruldu! Kalan can: ${zombie.userData.health}`);
            }

            showZombieDamageEffect(zombie) {
                // Ge√ßici kƒ±rmƒ±zƒ± renk efekti
                const originalColors = [];
                
                zombie.children.forEach((child, index) => {
                    if (child.material && child.material.color) {
                        originalColors[index] = child.material.color.getHex();
                        child.material.color.setHex(0xff4444); // Kƒ±rmƒ±zƒ±
                    }
                });
                
                // 200ms sonra orijinal renge d√∂nd√ºr
                setTimeout(() => {
                    zombie.children.forEach((child, index) => {
                        if (child.material && originalColors[index] !== undefined) {
                            child.material.color.setHex(originalColors[index]);
                        }
                    });
                }, 200);
            }

            createBulletTrail(targetPosition) {
                // Mermi izi √ßizgisi
                const points = [
                    new THREE.Vector3(0, 3, 0), // Oyuncu pozisyonu
                    new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z) // Hedef
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.7
                });
                
                const line = new THREE.Line(geometry, material);
                this.scene.add(line);
                
                // Kƒ±sa s√ºre sonra kaldƒ±r
                setTimeout(() => {
                    this.scene.remove(line);
                }, 100);
            }


            createResourcePoints() {
                // Kaynak sistemi kaldƒ±rƒ±ldƒ± - sadece tycoon
                console.log("Kaynak sistemi kaldƒ±rƒ±ldƒ±");
            }

            createRoads() {
                // Yol sistemi kaldƒ±rƒ±ldƒ±
                console.log("Yollar kaldƒ±rƒ±ldƒ±");
            }

            createSimpleRoad(x, y, z, width, length, material) {
                // Yol olu≈üturma fonksiyonu kaldƒ±rƒ±ldƒ±
                return null;
            }

            createFactoryFloor() {
                // Fabrika zemini kaldƒ±rƒ±ldƒ±
                console.log("Fabrika zemini kaldƒ±rƒ±ldƒ±");
                this.sceneObjects.factoryFloor = null;
            }

            createHouses() {
                // Ev sistemi kaldƒ±rƒ±ldƒ±
                console.log("Evler kaldƒ±rƒ±ldƒ±");
            }

            isPositionOnRoad(x, z, roadSpacing) {
                // Yol kontrol√º kaldƒ±rƒ±ldƒ± - artƒ±k yol yok
                return false;
            }

            createHouse(x, z, material) {
                // Ev olu≈üturma fonksiyonu kaldƒ±rƒ±ldƒ±
                return null;
            }

            createGoldCoins() {
                // Altƒ±n sistemi kaldƒ±rƒ±ldƒ± - sadece tycoon
                console.log("Altƒ±n sistemi kaldƒ±rƒ±ldƒ±");
            }

            createShelter() {
                // Barƒ±nak duvarlarƒ±
                const wallGeometry = new THREE.BoxGeometry(8, 4, 6);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x475569 });
                
                // Arka duvar
                const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
                backWall.position.set(0, 2, -3);
                backWall.castShadow = true;
                this.scene.add(backWall);

                // Sol duvar
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                leftWall.position.set(-4, 2, 0);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.castShadow = true;
                this.scene.add(leftWall);

                // Saƒü duvar
                const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
                rightWall.position.set(4, 2, 0);
                rightWall.rotation.y = Math.PI / 2;
                rightWall.castShadow = true;
                this.scene.add(rightWall);

                // √áatƒ±
                const roofGeometry = new THREE.ConeGeometry(6, 3, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x64748b });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 5, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                this.scene.add(roof);

                this.sceneObjects.shelter = { backWall, leftWall, rightWall, roof };
            }


            createFire() {
                // Ate≈ü geometrisi
                const fireGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                const fireMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xf97316,
                    emissive: 0xf97316,
                    emissiveIntensity: 0.5
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set(0, 1, 0);
                fire.castShadow = true;
                this.scene.add(fire);

                // Ate≈ü partik√ºlleri
                const particleCount = 50;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 2;
                    positions[i * 3 + 1] = Math.random() * 3;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

                    const color = new THREE.Color();
                    color.setHSL(0.1, 1, Math.random() * 0.5 + 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: false,
                    opacity: 0.8
                });

                const fireParticles = new THREE.Points(particles, particleMaterial);
                fireParticles.position.set(0, 1, 0);
                this.scene.add(fireParticles);

                this.sceneObjects.fire = { fire, particles: fireParticles };
            }

            createSurvivors() {
                // Survivor sistemi kaldƒ±rƒ±ldƒ± - sadece tycoon
                console.log("Survivor sistemi kaldƒ±rƒ±ldƒ±");
            }

            // addSurvivor fonksiyonu kaldƒ±rƒ±ldƒ±

            createSnowSystem() {
                // Kar sistemi - ba≈ütan render et, t√ºm harita alanƒ±na
                const snowCount = 2000; // Daha fazla kar par√ßacƒ±ƒüƒ±
                const snowGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(snowCount * 3);
                const velocities = new Float32Array(snowCount);

                // T√ºm harita alanƒ±na kar par√ßacƒ±klarƒ± yerle≈ütir
                for (let i = 0; i < snowCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * (this.worldMap.width + 50);
                    positions[i * 3 + 1] = Math.random() * 80 + 20; // Daha y√ºksekten ba≈üla
                    positions[i * 3 + 2] = (Math.random() - 0.5) * (this.worldMap.height + 50);
                    velocities[i] = Math.random() * 2 + 1;
                }

                snowGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

                const snowMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.9
                });

                const snowSystem = new THREE.Points(snowGeometry, snowMaterial);
                snowSystem.frustumCulled = false; // Her zaman render et
                snowSystem.visible = true;
                this.scene.add(snowSystem);
                
                this.sceneObjects.snowSystem = snowSystem;
            }

            startGame() {
                // Ba≈ülangƒ±√ß parasƒ±nƒ± totalEarned'a ekle
                this.gameState.totalEarned = this.tycoon.money;
                this.gameState.score = this.gameState.totalEarned;
                
                this.gameLoop();
                this.updateUI(); // UI'yi ba≈ülat
                this.updateTycoonUI(); // Tycoon UI'yi ba≈ülat
                
                // Farcade SDK ready call
                window.FarcadeSDK.singlePlayer.actions.ready();
            }

            gameLoop() {
                if (this.gameState.isGameOver) return;

                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                // Oyun bitti mi kontrol et
                if (this.gameState.isGameOver || this.gameState.gameWon) return;
                
                // Score = toplam kazanƒ±lan para (harcamalarla azalmaz)
                this.gameState.score = this.gameState.totalEarned;
                
                // Tycoon sistemini g√ºncelle
                this.updateTycoonSystem();
                
                // Gear collection ve machine breakdown
                this.updateGearSystem();
                this.updateMachineBreakdowns();
                
                // Zombi sistemini g√ºncelle
                this.updateZombieSystem();
                
                // Zaman kontrol√º
                this.checkTimeLimit();

                // Oyuncu hareketi
                this.updatePlayerMovement();

                // 3D animasyonlarƒ± g√ºncelle
                this.update3DAnimations();
                
                // UI'yi g√ºncelle
                this.updateUI();

                // Minimap kaldƒ±rƒ±ldƒ±
            }

            updateTycoonSystem() {
                const now = Date.now();
                
                // Gelir √ºretimi (saniye ba≈üƒ±nda anlƒ±k artƒ±≈ü, bozuk makineler hari√ß)
                if (now - this.tycoon.lastIncomeTime >= 1000) {
                    let actualIncome = this.tycoon.moneyPerSecond;
                    
                    // Subtract income from broken machines
                    this.gameState.brokenMachines.forEach(machineId => {
                        const upgrade = this.tycoon.upgrades.find(u => u.id === machineId);
                        if (upgrade) {
                            actualIncome -= upgrade.income;
                        }
                    });
                    
                    actualIncome = Math.max(actualIncome, 0);
                    this.tycoon.money += actualIncome;
                    this.gameState.totalEarned += actualIncome; // Track total earnings
                    this.tycoon.lastIncomeTime = now;
                    
                    // Debug log
                    if (this.gameState.brokenMachines.length > 0) {
                        console.log(`Income: ${this.tycoon.moneyPerSecond} - ${this.tycoon.moneyPerSecond - actualIncome} = ${actualIncome} (broken machines: ${this.gameState.brokenMachines.length})`);
                    }
                    
                    this.updateTycoonUI();
                }
                
                // Platform collision kontrol√º
                this.checkTycoonCollisions();
                
                // Platform renklerini g√ºncelle
                this.updatePlatformColors();
                
                // Oyun biti≈ü kontrol√º
                this.checkGameCompletion();
            }

            updateTycoonUI() {
                document.getElementById('moneyDisplay').textContent = `üí∞ $${Math.floor(this.tycoon.money)}`;
                
                // Calculate actual income (minus broken machines)
                let actualIncome = this.tycoon.moneyPerSecond;
                this.gameState.brokenMachines.forEach(machineId => {
                    const upgrade = this.tycoon.upgrades.find(u => u.id === machineId);
                    if (upgrade) {
                        actualIncome -= upgrade.income;
                    }
                });
                actualIncome = Math.max(actualIncome, 0);
                
                document.getElementById('incomeDisplay').textContent = `üìà +$${actualIncome}/sec`;
                
                // Sonraki upgrade bilgisi veya bozuk makine bilgisi
                if (this.gameState.brokenMachines.length > 0) {
                    const brokenCount = this.gameState.brokenMachines.length;
                    const repairCost = 3;
                    document.getElementById('upgradeInfo').innerHTML = 
                        `‚ö†Ô∏è ${brokenCount} machine(s) broken!<br>üîß Need ${repairCost} gears each to repair<br>‚öôÔ∏è Walk over gears to collect them`;
                } else {
                    const nextUpgrade = this.getNextUpgrade();
                if (nextUpgrade) {
                        document.getElementById('upgradeInfo').innerHTML = 
                            `üîÑ Next: ${nextUpgrade.name}<br>üí∞ Cost: $${nextUpgrade.cost}<br>üìà Income: +$${nextUpgrade.income}/sec`;
                    } else {
                        document.getElementById('upgradeInfo').innerHTML = 'üéâ All upgrades completed!';
                    }
                }
            }
            
            getNextUpgrade() {
                return this.tycoon.upgrades.find(upgrade => !upgrade.bought && this.canBuyUpgrade(upgrade));
            }
            
            checkTycoonCollisions() {
                if (!this.sceneObjects.player) return;
                
                const collisionRange = 2;
                
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const platformPos = platform.position;
                    
                    // Oyuncu merkezdeyken platform mesafesi kontrol√º
                    const distance = Math.sqrt(
                        Math.pow(platformPos.x, 2) + 
                        Math.pow(platformPos.z, 2)
                    );
                    
                    if (distance < collisionRange) {
                        const upgrade = platform.userData.upgrade;
                        
                        if (!upgrade.bought && this.canBuyUpgrade(upgrade)) {
                            this.buyUpgrade(upgrade);
                        } else if (upgrade.bought && this.gameState.brokenMachines.includes(upgrade.id)) {
                            // Try to repair broken machine
                            this.repairMachine(upgrade.id);
                        }
                    }
                });
            }
            
            buyUpgrade(upgrade) {
                console.log(`Upgrade satƒ±n alƒ±nƒ±yor: ${upgrade.name} - $${upgrade.cost}`);
                
                // Para d√º≈ü
                this.tycoon.money -= upgrade.cost;
                
                // Upgrade'i satƒ±n alƒ±nmƒ±≈ü olarak i≈üaretle
                upgrade.bought = true;
                
                // Geliri artƒ±r
                this.tycoon.moneyPerSecond += upgrade.income;
                
                // G√∂rsel objeler olu≈ütur
                this.createTycoonObject(upgrade);
                
                // Bilgi etiketini kaldƒ±r
                this.removeUpgradeInfo(upgrade.id);
                
                // UI'yi g√ºncelle
                this.updateTycoonUI();
                
                console.log(`‚úÖ ${upgrade.name} purchased! New income: +$${this.tycoon.moneyPerSecond}/sec`);
                
                // Haptic feedback
                window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }
            
            updatePlatformColors() {
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const upgrade = platform.userData.upgrade;
                    let newColor = 0x6b7280; // Gri - kilitli
                    
                    if (upgrade.bought && this.gameState.brokenMachines.includes(upgrade.id)) {
                        newColor = 0xff0000; // Kƒ±rmƒ±zƒ± - bozuk makine
                        console.log(`Platform ${upgrade.name} is RED (broken)`);
                    } else if (upgrade.bought) {
                        newColor = 0x10b981; // Ye≈üil - satƒ±n alƒ±nmƒ±≈ü ve √ßalƒ±≈üƒ±yor
                    } else if (this.canBuyUpgrade(upgrade)) {
                        newColor = 0xf59e0b; // Sarƒ± - satƒ±n alƒ±nabilir
                    }
                    
                    platform.material.color.setHex(newColor);
                });
            }
            
            updateGearSystem() {
                // Animate gears rotation
                this.sceneObjects.gears.forEach(gear => {
                    gear.rotation.y += gear.userData.rotationSpeed;
                });
                
                // Check gear collection
                this.checkGearCollection();
            }

            updateZombieSystem() {
                // Zombi spawn kontrol√º
                this.spawnZombie();
                
                // T√ºm zombileri g√ºncelle
                for (let i = this.sceneObjects.zombies.length - 1; i >= 0; i--) {
                    const zombie = this.sceneObjects.zombies[i];
                    this.updateZombie(zombie, i);
                }
                
                // √ñl√º zombileri temizle
                this.cleanupDeadZombies();
            }

            updateZombie(zombie, index) {
                if (!zombie || !zombie.userData) return;
                
                const zombieData = zombie.userData;
                const now = Date.now();
                
                // √ñl√º zombi kontrol√º
                if (zombieData.state === 'dead') {
                    if (now - zombieData.deathTime > 3000) { // 3 saniye sonra kaybolsun
                        this.removeZombie(index);
                    }
                    return;
                }
                
                // Oyuncuya olan mesafe
                const distance = Math.sqrt(
                    Math.pow(zombie.position.x, 2) + 
                    Math.pow(zombie.position.z, 2)
                );
                
                // Zombi davranƒ±≈ülarƒ±
                if (distance < 2) {
                    // Yakƒ±n mesafede - saldƒ±rƒ±
                    this.zombieAttack(zombie);
                } else if (distance < 30) {
                    // Orta mesafede - oyuncuya doƒüru hareket
                    this.moveZombieTowardsPlayer(zombie);
                } else {
                    // √áok uzakta - zombiyi sil (performans i√ßin)
                    this.removeZombie(index);
                }
                
                // Zombi animasyonu
                this.animateZombie(zombie);
            }

            moveZombieTowardsPlayer(zombie) {
                if (!zombie || !zombie.userData) return;
                
                const zombieData = zombie.userData;
                
                // Oyuncuya doƒüru y√∂n hesapla (oyuncu her zaman merkezde)
                const direction = new THREE.Vector3(
                    -zombie.position.x,
                    0,
                    -zombie.position.z
                ).normalize();
                
                // Zombiyi hareket ettir
                zombie.position.x += direction.x * zombieData.speed;
                zombie.position.z += direction.z * zombieData.speed;
                
                // Zombiyi oyuncuya doƒüru d√∂nd√ºr
                zombie.lookAt(0, zombie.position.y, 0);
                zombie.rotation.y += Math.PI; // D√ºzeltme
            }

            zombieAttack(zombie) {
                if (!zombie || !zombie.userData) return;
                
                const zombieData = zombie.userData;
                const now = Date.now();
                
                // Saldƒ±rƒ± cooldown kontrol√º
                if (now - zombieData.lastAttack < zombieData.attackCooldown) {
                    return;
                }
                
                // Oyuncuya hasar ver
                this.playerTakeDamage(zombieData.damage);
                zombieData.lastAttack = now;
                
                // Saldƒ±rƒ± animasyonu
                this.playZombieAttackAnimation(zombie);
                
                console.log(`Zombi saldƒ±rdƒ±! Hasar: ${zombieData.damage}`);
            }

            playerTakeDamage(damage) {
                this.gameState.health -= damage;
                
                if (this.gameState.health <= 0) {
                    this.gameState.health = 0;
                    this.gameState.isGameOver = true;
                    this.showGameOver(false, 'Zombiler tarafƒ±ndan √∂ld√ºr√ºld√ºn!');
                }
                
                // Ekran titre≈üimi efekti
                if (window.FarcadeSDK && window.FarcadeSDK.singlePlayer.actions.hapticFeedback) {
                    window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
                }
                
                console.log(`Oyuncu hasar aldƒ±! Kalan can: ${this.gameState.health}`);
            }

            // Eski yakƒ±n mesafe √∂ld√ºrme sistemi kaldƒ±rƒ±ldƒ± - artƒ±k silah sistemi kullanƒ±lƒ±yor

            killZombie(zombie, index) {
                if (!zombie || !zombie.userData) return;
                
                // Zombiyi √∂ld√º olarak i≈üaretle
                zombie.userData.state = 'dead';
                zombie.userData.deathTime = Date.now();
                
                // √ñl√ºm animasyonu - zombiyi yere d√º≈ü√ºr
                zombie.rotation.z = Math.PI / 2; // Yan yatar
                zombie.position.y = 1;
                
                // Rengi deƒüi≈ütir (gri yap)
                zombie.children.forEach(child => {
                    if (child.material) {
                        child.material = child.material.clone();
                        child.material.color.setHex(0x444444);
                    }
                });
                
                // Puanlama ve √∂d√ºller
                this.gameState.zombiesKilled++;
                
                // Zombi √∂ld√ºrme bonusu
                const killBonus = 25;
                this.tycoon.money += killBonus;
                this.gameState.totalEarned += killBonus;
                
                console.log(`Zombi √∂ld√ºr√ºld√º! +$${killBonus} bonus. Toplam √∂ld√ºr√ºlen: ${this.gameState.zombiesKilled}`);
                
                // UI g√ºncelle
                this.updateTycoonUI();
            }

            removeZombie(index) {
                if (index >= 0 && index < this.sceneObjects.zombies.length) {
                    const zombie = this.sceneObjects.zombies[index];
                    this.scene.remove(zombie);
                    this.sceneObjects.zombies.splice(index, 1);
                }
            }

            cleanupDeadZombies() {
                for (let i = this.sceneObjects.zombies.length - 1; i >= 0; i--) {
                    const zombie = this.sceneObjects.zombies[i];
                    
                    if (!zombie || !zombie.userData) {
                        this.removeZombie(i);
                        continue;
                    }
                    
                    if (zombie.userData.state === 'dead' && 
                        Date.now() - zombie.userData.deathTime > 3000) {
                        this.removeZombie(i);
                    }
                }
            }

            animateZombie(zombie) {
                if (!zombie || !zombie.userData) return;
                
                const time = Date.now() * 0.001;
                const zombieData = zombie.userData;
                
                if (zombieData.state === 'dead') return;
                
                // Y√ºr√ºme animasyonu - daha yava≈ü ve sallantƒ±lƒ±
                const walkSpeed = 3;
                const legSwing = Math.sin(time * walkSpeed) * 0.2;
                
                // Bacaklarƒ± hareket ettir
                const leftLeg = zombie.children.find(child => child.position.x === -0.25);
                const rightLeg = zombie.children.find(child => child.position.x === 0.25);
                
                if (leftLeg) leftLeg.rotation.x = legSwing;
                if (rightLeg) rightLeg.rotation.x = -legSwing;
                
                // Kollarƒ± da salla (zombi gibi)
                const leftArm = zombie.children.find(child => child.position.x === -0.7);
                const rightArm = zombie.children.find(child => child.position.x === 0.7);
                
                if (leftArm) leftArm.rotation.x = -legSwing * 0.3;
                if (rightArm) rightArm.rotation.x = legSwing * 0.3;
                
                // Hafif sallanma hareketi
                zombie.position.y = 2.8 + Math.sin(time * walkSpeed) * 0.05;
                
                // G√∂zlerin parlamasƒ±
                const eyeFlicker = Math.sin(time * 10) * 0.3 + 0.7;
                zombie.children.forEach(child => {
                    if (child.material && child.material.emissive && child.material.emissive.r > 0) {
                        child.material.emissive.setRGB(eyeFlicker * 0.3, 0, 0);
                    }
                });
            }

            playZombieAttackAnimation(zombie) {
                if (!zombie) return;
                
                // Saldƒ±rƒ± animasyonu - kollarƒ± √∂ne uzat
                const leftArm = zombie.children.find(child => child.position.x === -0.7);
                const rightArm = zombie.children.find(child => child.position.x === 0.7);
                
                if (leftArm) {
                    leftArm.rotation.x = -Math.PI / 3;
                    setTimeout(() => {
                        if (leftArm) leftArm.rotation.x = 0;
                    }, 500);
                }
                
                if (rightArm) {
                    rightArm.rotation.x = -Math.PI / 3;
                    setTimeout(() => {
                        if (rightArm) rightArm.rotation.x = 0;
                    }, 500);
                }
            }
            
            updateMachineBreakdowns() {
                const now = Date.now();
                
                // Random machine breakdown (every 10-20 seconds for testing)
                if (now - this.gameState.lastBreakdownTime > 10000 + Math.random() * 10000) {
                    this.breakRandomMachine();
                    this.gameState.lastBreakdownTime = now;
                }
                
                // Update broken machine visuals
                this.updateBrokenMachineVisuals();
            }
            
            checkGearCollection() {
                if (!this.sceneObjects.player) return;
                
                const collectionRange = 1.5;
                
                for (let i = this.sceneObjects.gears.length - 1; i >= 0; i--) {
                    const gear = this.sceneObjects.gears[i];
                    
                    // Calculate distance to player (player is always at center)
                    const distance = Math.sqrt(
                        Math.pow(gear.position.x, 2) + 
                        Math.pow(gear.position.z, 2)
                    );
                    
                    if (distance < collectionRange) {
                        // Collect gear
                        this.gameState.gears++;
                        
                        // Add money bonus for collecting gear
                        const gearBonus = 10;
                        this.tycoon.money += gearBonus;
                        this.gameState.totalEarned += gearBonus;
                        
                        console.log(`Gear collected! +$${gearBonus} Total gears: ${this.gameState.gears}`);
                        
                        // Remove gear from scene
                        this.scene.remove(gear);
                        this.sceneObjects.gears.splice(i, 1);
                        
                        // Spawn new gear to maintain count
                        setTimeout(() => this.spawnGear(), 2000);
                        
                        // Update UI
                        this.updateUI();
                        this.updateTycoonUI();
                        
                        // Haptic feedback
                        if (typeof Farcade !== 'undefined' && Farcade.hapticFeedback) {
                            Farcade.hapticFeedback();
                        }
                    }
                }
            }
            
            breakRandomMachine() {
                // Get purchased machines that aren't already broken
                const availableMachines = this.tycoon.upgrades.filter(upgrade => 
                    upgrade.bought && !this.gameState.brokenMachines.includes(upgrade.id)
                );
                
                if (availableMachines.length === 0) return;
                
                // Break random machine
                const randomMachine = availableMachines[Math.floor(Math.random() * availableMachines.length)];
                this.gameState.brokenMachines.push(randomMachine.id);
                
                console.log(`‚ö†Ô∏è ${randomMachine.name} broke down! Needs 3 gears to repair.`);
                console.log(`Broken machines: [${this.gameState.brokenMachines.join(', ')}]`);
                
                // Update platform colors and UI immediately
                this.updatePlatformColors();
                this.updateTycoonUI();
            }
            
            updateBrokenMachineVisuals() {
                // Make broken machines flash red
                this.gameState.brokenMachines.forEach(machineId => {
                    const machine = this.sceneObjects.tycoonObjects.find(obj => 
                        obj.userData.type === 'tycoonObject' && obj.userData.upgradeId === machineId
                    );
                    
                    if (machine) {
                        const time = Date.now() * 0.003;
                        const flash = Math.sin(time) * 0.5 + 0.5;
                        machine.material.emissive.setRGB(flash * 0.5, 0, 0); // Red flash
                    }
                });
            }
            
            repairMachine(machineId) {
                const gearCost = 3;
                
                if (this.gameState.gears >= gearCost) {
                    // Remove gears
                    this.gameState.gears -= gearCost;
                    
                    // Remove from broken list
                    const index = this.gameState.brokenMachines.indexOf(machineId);
                    if (index > -1) {
                        this.gameState.brokenMachines.splice(index, 1);
                    }
                    
                    // Reset machine visual
                    const machine = this.sceneObjects.tycoonObjects.find(obj => 
                        obj.userData.type === 'tycoonObject' && obj.userData.upgradeId === machineId
                    );
                    
                    if (machine) {
                        machine.material.emissive.setRGB(0, 0, 0); // Remove flash
                    }
                    
                    const upgrade = this.tycoon.upgrades.find(u => u.id === machineId);
                    console.log(`üîß ${upgrade.name} repaired! -${gearCost} gears`);
                    
                    // Update platform colors immediately
                    this.updatePlatformColors();
                    this.updateUI();
                    this.updateTycoonUI();
                    
                    return true;
                }
                
                console.log(`Need ${gearCost} gears to repair. Current: ${this.gameState.gears}`);
                return false;
            }
            
            checkTimeLimit() {
                if (this.gameState.gameEnded) return;
                
                const elapsedTime = (Date.now() - this.gameState.startTime) / 1000;
                const remainingTime = this.gameState.timeLimit - elapsedTime;
                
                if (remainingTime <= 0) {
                    this.gameState.isGameOver = true;
                    this.gameState.gameEnded = true;
                    this.showGameOver(false, 'Time is up! You ran out of time.');
                }
            }
            
            checkGameCompletion() {
                // T√ºm upgrade'ler satƒ±n alƒ±ndƒ± mƒ± kontrol et
                const allUpgradesBought = this.tycoon.upgrades.every(upgrade => upgrade.bought);
                
                if (allUpgradesBought && !this.gameState.gameWon) {
                    this.gameState.gameWon = true;
                    this.gameState.gameEnded = true;
                    
                    // Calculate remaining time bonus
                    const elapsedTime = (Date.now() - this.gameState.startTime) / 1000;
                    const remainingTime = Math.max(0, this.gameState.timeLimit - elapsedTime);
                    
                    // Time bonus: 10 points per remaining second
                    this.gameState.timeBonus = Math.floor(remainingTime * 10);
                    
                    const remainingMinutes = Math.floor(remainingTime / 60);
                    const remainingSeconds = Math.floor(remainingTime % 60);
                    const timeText = `${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                    
                    this.showGameOver(true, `Congratulations! Completed with ${timeText} remaining! Time Bonus: +${this.gameState.timeBonus} points`);
                }
            }
            
            isUpgradeBought(upgradeId) {
                const upgrade = this.tycoon.upgrades.find(u => u.id === upgradeId);
                return upgrade ? upgrade.bought : false;
            }
            
            createTycoonObject(upgrade) {
                let geometry, material, mesh;
                
                switch(upgrade.id) {
                    case 1: // Storage Area
                        // Create wooden pallet
                        geometry = new THREE.BoxGeometry(2, 0.3, 1.5);
                        material = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 0.4, upgrade.position.z);
                        break;
                        
                    case 2: // Production Machine
                        geometry = new THREE.BoxGeometry(2.5, 2, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x4682B4 }); // Steel blue
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 1.2, upgrade.position.z);
                        break;
                        
                    case 3: // Conveyor Belt
                        geometry = new THREE.BoxGeometry(3, 0.5, 0.8);
                        material = new THREE.MeshLambertMaterial({ color: 0x2F4F4F }); // Dark gray
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 0.5, upgrade.position.z);
                        break;
                        
                    case 4: // Packaging Unit
                        geometry = new THREE.BoxGeometry(2.2, 1.8, 2.2);
                        material = new THREE.MeshLambertMaterial({ color: 0xFF8C00 }); // Orange
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 1.1, upgrade.position.z);
                        break;
                        
                    case 5: // Shipping Center
                        geometry = new THREE.BoxGeometry(3, 2.5, 2.5);
                        material = new THREE.MeshLambertMaterial({ color: 0xDC143C }); // Red
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 1.4, upgrade.position.z);
                        break;
                        
                    case 6: // Quality Control
                        geometry = new THREE.BoxGeometry(1.5, 2.5, 1.5);
                        material = new THREE.MeshLambertMaterial({ color: 0x32CD32 }); // Green
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 1.4, upgrade.position.z);
                        break;
                        
                    case 7: // R&D Center
                        geometry = new THREE.BoxGeometry(3, 3, 3);
                        material = new THREE.MeshLambertMaterial({ color: 0x4169E1 }); // Royal blue
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 1.7, upgrade.position.z);
                        break;
                        
                    case 8: // Automation System
                        geometry = new THREE.BoxGeometry(4, 2, 4);
                        material = new THREE.MeshLambertMaterial({ color: 0x800080 }); // Purple
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 1.2, upgrade.position.z);
                        break;
                        
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(upgrade.position.x, 0.7, upgrade.position.z);
                }
                
                if (mesh) {
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { type: 'tycoonObject', upgradeId: upgrade.id };
                    mesh.frustumCulled = false;
                    
                    this.scene.add(mesh);
                    this.sceneObjects.tycoonObjects.push(mesh);
                    upgrade.objects.push(mesh);
                }
                
                console.log(`Tycoon objesi olu≈üturuldu: ${upgrade.name}`);
            }
            
            removeUpgradeInfo(upgradeId) {
                for (let i = this.sceneObjects.tycoonObjects.length - 1; i >= 0; i--) {
                    const obj = this.sceneObjects.tycoonObjects[i];
                    if (obj.userData.type === 'upgradeInfo' && obj.userData.upgradeId === upgradeId) {
                        this.scene.remove(obj);
                        this.sceneObjects.tycoonObjects.splice(i, 1);
                    }
                }
            }

            // Tycoon UI ve challenge fonksiyonlarƒ± kaldƒ±rƒ±ldƒ±

            showGameOver(won, message) {
                // Calculate final score: money + timeBonus
                const totalScore = this.tycoon.money + this.gameState.timeBonus;
                
                console.log(`Game Over: ${won ? 'WON' : 'LOST'} - ${message}`);
                console.log(`Final Score: $${Math.floor(totalScore)}`);
                console.log(`Breakdown: Money: $${this.tycoon.money}, Time Bonus: $${this.gameState.timeBonus}`);
                
                // Notify Farcade with final score
                window.FarcadeSDK.singlePlayer.actions.gameOver({ 
                    score: Math.floor(totalScore)
                });
            }

            checkPlatformCollisions() {
                if (!this.sceneObjects.player) return;
                
                const collisionRange = 1.5;
                const playerWorldX = this.worldMap.playerPosition.x;
                const playerWorldZ = this.worldMap.playerPosition.z;
                
                // Check normal platforms (move with camera)
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const platformPos = platform.position;
                    
                    // Player is at center, check distance to platform
                    const distance = Math.sqrt(
                        Math.pow(platformPos.x, 2) + 
                        Math.pow(platformPos.z, 2)
                    );
                    
                    if (distance < collisionRange) {
                        const upgrade = platform.userData.upgrade;
                        
                        if (!upgrade.bought && this.canPurchaseUpgrade(upgrade)) {
                            this.purchaseUpgrade(upgrade, platform);
                        }
                    }
                });
                
                // Red platform collision removed
            }

            canPurchaseUpgrade(upgrade) {
                // Money check for normal platforms
                if (this.tycoonState.money < upgrade.price) {
                    return false;
                }
                
                // Prerequisite check - sequential upgrade system
                if (upgrade.requires) {
                    const requiredUpgrade = this.tycoonState.availableUpgrades.find(u => u.id === upgrade.requires);
                    if (!requiredUpgrade || !requiredUpgrade.bought) {
                        console.log(`‚ö†Ô∏è You must first purchase ${requiredUpgrade ? requiredUpgrade.name : upgrade.requires}!`);
                        return false;
                    }
                }
                
                return true;
            }

            purchaseUpgrade(upgrade, platform) {
                console.log(`Purchasing upgrade: ${upgrade.name} - $${upgrade.price}`);
                
                // Normal upgrade behavior only
                // Deduct money
                this.tycoonState.money -= upgrade.price;
                
                // Mark upgrade as purchased
                upgrade.bought = true;
                
                // Increase income
                const incomeIncrease = parseInt(upgrade.description.match(/\d+/)[0]);
                this.tycoonState.moneyPerSecond += incomeIncrease;
                
                // Change platform color
                platform.material.color.setHex(0x10b981); // Green
                
                // Create upgrade object
                this.createUpgradeObject(upgrade);
                
                // Remove upgrade label
                this.removeUpgradeLabel(upgrade.id);
                
                // Update platform colors for next upgrades
                this.updatePlatformColors();
                
                console.log(`‚úÖ ${upgrade.name} purchased! New income: +$${this.tycoonState.moneyPerSecond}/sec`);
                
                // Update UI
                this.updateTycoonUI();
                
                // Haptic feedback
                window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }

            // checkRedPlatformCollision removed - now uses normal platform collision system

            createUpgradeObject(upgrade) {
                let geometry, material, mesh;
                
                switch(upgrade.id) {
                    case 'raw_material':
                        // Hammadde deposu - b√ºy√ºk dikd√∂rtgen depo
                        geometry = new THREE.BoxGeometry(2, 2.5, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Kahverengi
                        break;
                    case 'conveyor_input':
                        // Konveyor bant - uzun ve d√º≈ü√ºk
                        geometry = new THREE.BoxGeometry(2.5, 0.3, 0.8);
                        material = new THREE.MeshLambertMaterial({ color: 0x2F4F4F }); // Koyu gri
                        break;
                    case 'processing_machine':
                        // ƒ∞≈üleme makinesi - karma≈üƒ±k makine g√∂r√ºn√ºm√º
                        geometry = new THREE.BoxGeometry(2, 2, 2);
                        material = new THREE.MeshLambertMaterial({ color: 0x4682B4 }); // √áelik mavisi
                        break;
                    case 'quality_control':
                        // Kalite kontrol - y√ºksek ince makine
                        geometry = new THREE.BoxGeometry(1.5, 2.5, 1.5);
                        material = new THREE.MeshLambertMaterial({ color: 0x32CD32 }); // Ye≈üil
                        break;
                    case 'packaging':
                        // Paketleme √ºnitesi - orta boy kare
                        geometry = new THREE.BoxGeometry(2.2, 1.8, 2.2);
                        material = new THREE.MeshLambertMaterial({ color: 0xFF8C00 }); // Turuncu
                        break;
                    case 'shipping':
                        // Kargo √ºnitesi - b√ºy√ºk y√ºkleme rampasƒ±
                        geometry = new THREE.BoxGeometry(3, 2.5, 2.5);
                        material = new THREE.MeshLambertMaterial({ color: 0xDC143C }); // Kƒ±rmƒ±zƒ±
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                }
                
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(upgrade.position.x, geometry.parameters ? geometry.parameters.height/2 : 1, upgrade.position.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: 'upgradeObject', upgradeId: upgrade.id };
                
                this.scene.add(mesh);
                this.sceneObjects.tycoonBuildings.push(mesh);
                this.tycoonState.upgradeObjects.push(mesh);
                
                // Fabrika makineleri i√ßin ek detaylar ekle
                this.addMachineDetails(upgrade, mesh);
            }

            addMachineDetails(upgrade, mainMesh) {
                const position = mainMesh.position;
                
                switch(upgrade.id) {
                    case 'processing_machine':
                        // Makine √ºst√ºnde boru sistemi
                        const pipe = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, 1, 8),
                            new THREE.MeshLambertMaterial({ color: 0x708090 })
                        );
                        pipe.position.set(position.x, position.y + 1.5, position.z);
                        pipe.castShadow = true;
                        this.scene.add(pipe);
                        this.sceneObjects.tycoonBuildings.push(pipe);
                        break;
                        
                    case 'quality_control':
                        // Kalite kontrol i√ßin tarayƒ±cƒ± ƒ±≈üƒ±k
                        const scanner = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.3, 1.8),
                            new THREE.MeshLambertMaterial({ color: 0x00FF00, emissive: 0x003300 })
                        );
                        scanner.position.set(position.x, position.y + 0.8, position.z);
                        scanner.castShadow = true;
                        this.scene.add(scanner);
                        this.sceneObjects.tycoonBuildings.push(scanner);
                        break;
                        
                    case 'shipping':
                        // Kargo i√ßin y√ºkleme rampasƒ±
                        const ramp = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 0.2, 3),
                            new THREE.MeshLambertMaterial({ color: 0x696969 })
                        );
                        ramp.position.set(position.x + 1.5, position.y - 1, position.z);
                        ramp.rotation.z = -0.3;
                        ramp.castShadow = true;
                        this.scene.add(ramp);
                        this.sceneObjects.tycoonBuildings.push(ramp);
                        break;
                }
            }

            removeUpgradeLabel(upgradeId) {
                // Upgrade etiketini ve step indicator'ƒ± bul ve kaldƒ±r
                for (let i = this.sceneObjects.tycoonBuildings.length - 1; i >= 0; i--) {
                    const building = this.sceneObjects.tycoonBuildings[i];
                    if ((building.userData.type === 'upgradeLabel' || building.userData.type === 'stepIndicator') && 
                        building.userData.upgradeId === upgradeId) {
                        this.scene.remove(building);
                        this.sceneObjects.tycoonBuildings.splice(i, 1);
                    }
                }
            }

            // Eski updatePlatformColors fonksiyonu kaldƒ±rƒ±ldƒ± - yeni versiyonu kullanƒ±lƒ±yor

            updatePlayerMovement() {
                if (!this.sceneObjects.player) return;

                let moveX = 0;
                let moveZ = 0;

                // Kamera a√ßƒ±sƒ±na g√∂re hareket eksenlerini ayarla
                // Kamera (-15, 20, 15) pozisyonunda, merkeze bakƒ±yor
                // Bu y√ºzden hareket eksenlerini kameranƒ±n bakƒ±≈ü a√ßƒ±sƒ±na g√∂re ayarlayalƒ±m
                const cameraAngle = Math.atan2(-15, 15); // Kamera a√ßƒ±sƒ± (g√ºncellenmi≈ü)

                // Klavye kontrolleri - karakter 180 derece d√∂nd√ºr√ºld√ºƒü√º i√ßin normal y√∂nler
                if (this.movement.keys.w || this.movement.keys.ArrowUp) {
                    // ƒ∞leri - kameranƒ±n baktƒ±ƒüƒ± y√∂n
                    moveX -= Math.sin(cameraAngle) * this.movement.speed;
                    moveZ -= Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.s || this.movement.keys.ArrowDown) {
                    // Geri - kameranƒ±n baktƒ±ƒüƒ± y√∂n√ºn tersi
                    moveX += Math.sin(cameraAngle) * this.movement.speed;
                    moveZ += Math.cos(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.a || this.movement.keys.ArrowLeft) {
                    // Sol - kameranƒ±n soluna doƒüru
                    moveX -= Math.cos(cameraAngle) * this.movement.speed;
                    moveZ += Math.sin(cameraAngle) * this.movement.speed;
                }
                if (this.movement.keys.d || this.movement.keys.ArrowRight) {
                    // Saƒü - kameranƒ±n saƒüƒ±na doƒüru
                    moveX += Math.cos(cameraAngle) * this.movement.speed;
                    moveZ -= Math.sin(cameraAngle) * this.movement.speed;
                }

                // Joystick kontrolleri - karakter d√∂nd√ºr√ºld√ºƒü√º i√ßin normal eksen sistemi
                moveX -= this.movement.joystick.x * Math.cos(cameraAngle) * this.movement.speed;
                moveZ += this.movement.joystick.x * Math.sin(cameraAngle) * this.movement.speed;
                moveX -= this.movement.joystick.y * Math.sin(cameraAngle) * this.movement.speed;
                moveZ -= this.movement.joystick.y * Math.cos(cameraAngle) * this.movement.speed;

                // Hareket y√∂n√ºn√º kaydet (ni≈üan alma i√ßin)
                if (Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01) {
                    // Hareket y√∂n√ºn√º normalize et
                    const moveLength = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    this.gameState.aiming.lastMoveDirection.x = moveX / moveLength;
                    this.gameState.aiming.lastMoveDirection.z = moveZ / moveLength;
                    this.gameState.aiming.aimDirection.x = moveX / moveLength;
                    this.gameState.aiming.aimDirection.z = moveZ / moveLength;
                    
                    // Oyuncuyu hareket y√∂n√ºne d√∂nd√ºr
                    this.rotatePlayerToMoveDirection();
                }

                // Oyuncuyu hareket ettir
                const newX = this.sceneObjects.player.position.x + moveX;
                const newZ = this.sceneObjects.player.position.z + moveZ;

                // Sƒ±nƒ±r kontrol√º
                const halfWidth = this.worldMap.width / 2 - 2;
                const halfHeight = this.worldMap.height / 2 - 2;

                // Collision kontrol√º kaldƒ±rƒ±ldƒ± (daƒü ve aƒüa√ß yok)
                let canMove = true;

                if (Math.abs(newX) < halfWidth && Math.abs(newZ) < halfHeight && canMove) {
                    this.sceneObjects.player.position.x = newX;
                    this.sceneObjects.player.position.z = newZ;

                    // Oyuncu pozisyonunu g√ºncelle
                    this.worldMap.playerPosition.x = newX;
                    this.worldMap.playerPosition.z = newZ;

                    // ƒ∞zole bakƒ±≈ü a√ßƒ±sƒ± - oyuncu merkezde kalƒ±r
                    this.updateIsometricView();
                }
            }

            rotatePlayerToMoveDirection() {
                if (!this.sceneObjects.player) return;
                
                const moveDir = this.gameState.aiming.aimDirection;
                const targetRotation = Math.atan2(moveDir.x, moveDir.z);
                
                // Yumu≈üak d√∂nd√ºrme
                const currentRotation = this.sceneObjects.player.rotation.y;
                const rotationDiff = targetRotation - currentRotation;
                
                // En kƒ±sa yolu bul
                let shortestRotation = rotationDiff;
                if (rotationDiff > Math.PI) shortestRotation -= 2 * Math.PI;
                if (rotationDiff < -Math.PI) shortestRotation += 2 * Math.PI;
                
                // Hƒ±zlƒ± d√∂nd√ºrme
                const rotationSpeed = 0.2;
                this.sceneObjects.player.rotation.y += shortestRotation * rotationSpeed;
            }

            updateIsometricView() {
                if (!this.sceneObjects.player) return;

                // Oyuncuyu her zaman kamera merkezine ta≈üƒ±
                const playerWorldPos = this.sceneObjects.player.position.clone();
                
                // T√ºm sahne objelerini oyuncunun tersi y√∂nde hareket ettir
                const offsetX = -playerWorldPos.x;
                const offsetZ = -playerWorldPos.z;

                // D√ºnya objelerini hareket ettir
                if (this.sceneObjects.world) {
                    this.sceneObjects.world.ground.position.x = offsetX;
                    this.sceneObjects.world.ground.position.z = offsetZ;
                    this.sceneObjects.world.snow.position.x = offsetX;
                    this.sceneObjects.world.snow.position.z = offsetZ;
                }



                // Survival √∂ƒüeleri kaldƒ±rƒ±ldƒ± - sadece tycoon

                // Yollarƒ± hareket ettir
                this.sceneObjects.roads.forEach(road => {
                    road.position.x += offsetX;
                    road.position.z += offsetZ;
                });

                // Evleri hareket ettir
                this.sceneObjects.houses.forEach(house => {
                    house.position.x += offsetX;
                    house.position.z += offsetZ;
                });

                // Tycoon platformlarƒ±nƒ± hareket ettir
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    platform.position.x += offsetX;
                    platform.position.z += offsetZ;
                });
                
                // Tycoon objelerini hareket ettir
                this.sceneObjects.tycoonObjects.forEach(obj => {
                    obj.position.x += offsetX;
                    obj.position.z += offsetZ;
                });
                
                // Gearlarƒ± hareket ettir
                this.sceneObjects.gears.forEach(gear => {
                    gear.position.x += offsetX;
                    gear.position.z += offsetZ;
                });

                // Zombileri hareket ettir
                this.sceneObjects.zombies.forEach(zombie => {
                    zombie.position.x += offsetX;
                    zombie.position.z += offsetZ;
                });

                // Kar sistemini hareket ettir
                if (this.sceneObjects.snowSystem) {
                    this.sceneObjects.snowSystem.position.x += offsetX;
                    this.sceneObjects.snowSystem.position.z += offsetZ;
                }

                // Oyuncuyu merkeze ta≈üƒ± (Y pozisyonunu koru)
                const currentY = this.sceneObjects.player.position.y;
                this.sceneObjects.player.position.x = 0;
                this.sceneObjects.player.position.z = 0;
                this.sceneObjects.player.position.y = currentY;
            }

            // checkResourceCollection fonksiyonu kaldƒ±rƒ±ldƒ±

            // checkGoldCollection fonksiyonu kaldƒ±rƒ±ldƒ±

            // updateMinimap fonksiyonu kaldƒ±rƒ±ldƒ±

            update3DAnimations() {
                const time = Date.now() * 0.001;

                // Oyuncu y√ºr√ºme animasyonu
                if (this.sceneObjects.player) {
                    const player = this.sceneObjects.player;
                    
                    // Hareket durumunu kontrol et
                    const isMoving = this.movement.keys.w || this.movement.keys.a || 
                                   this.movement.keys.s || this.movement.keys.d ||
                                   this.movement.keys.ArrowUp || this.movement.keys.ArrowLeft ||
                                   this.movement.keys.ArrowDown || this.movement.keys.ArrowRight ||
                                   Math.abs(this.movement.joystick.x) > 0.1 || Math.abs(this.movement.joystick.y) > 0.1;
                    
                    if (isMoving) {
                        // Y√ºr√ºme animasyonu - bacaklarƒ± hareket ettir
                        const walkSpeed = 8; // Y√ºr√ºme hƒ±zƒ±
                        const legSwing = Math.sin(time * walkSpeed) * 0.3; // Bacak sallanma miktarƒ±
                        
                        // Sol bacak
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        if (leftLeg) {
                            leftLeg.rotation.x = legSwing;
                        }
                        
                        // Saƒü bacak
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        if (rightLeg) {
                            rightLeg.rotation.x = -legSwing; // Ters y√∂nde hareket
                        }
                        
                        // Kollarƒ± da hafif√ße salla
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftArm) leftArm.rotation.x = -legSwing * 0.5;
                        if (rightArm) rightArm.rotation.x = legSwing * 0.5;
                        
                        // Hafif yukarƒ±-a≈üaƒüƒ± hareket (adƒ±m atma efekti)
                        player.position.y = 3 + Math.abs(Math.sin(time * walkSpeed)) * 0.1;
                    } else {
                        // Durduƒüunda bacaklarƒ± d√ºzelt
                        const leftLeg = player.children.find(child => child.position.x === -0.3);
                        const rightLeg = player.children.find(child => child.position.x === 0.3);
                        const leftArm = player.children.find(child => child.position.x === -0.8);
                        const rightArm = player.children.find(child => child.position.x === 0.8);
                        
                        if (leftLeg) leftLeg.rotation.x = 0;
                        if (rightLeg) rightLeg.rotation.x = 0;
                        if (leftArm) leftArm.rotation.x = 0;
                        if (rightArm) rightArm.rotation.x = 0;
                        
                        // Y pozisyonunu sƒ±fƒ±rla
                        player.position.y = 3;
                    }
                }

                // Kar animasyonu - basitle≈ütirilmi≈ü
                if (this.sceneObjects.snowSystem) {
                    const positions = this.sceneObjects.snowSystem.geometry.attributes.position.array;
                    const velocities = this.sceneObjects.snowSystem.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= velocities[i / 3] * 0.01; // Sabit kar hƒ±zƒ±
                        positions[i] += Math.sin(time + i) * 0.002; // Hafif r√ºzgar
                        
                        if (positions[i + 1] < -5) {
                            positions[i + 1] = 50;
                            positions[i] = (Math.random() - 0.5) * 100;
                            positions[i + 2] = (Math.random() - 0.5) * 100;
                        }
                    }
                    this.sceneObjects.snowSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Survivor animasyonu kaldƒ±rƒ±ldƒ±
            }

            render() {
                // Three.js sahneyi render et - t√ºm objeleri her zaman render et
                this.camera.position.set(-15, 20, 15);
                this.camera.lookAt(0, 0, 0);
                
                // T√ºm objeleri g√∂r√ºn√ºr yap
                this.scene.traverse((child) => {
                    if (child.isMesh || child.isPoints) {
                        child.visible = true;
                        child.frustumCulled = false;
                    }
                });
                
                this.renderer.clear();
                this.renderer.render(this.scene, this.camera);
            }


            // resourceDecayLoop fonksiyonu kaldƒ±rƒ±ldƒ±

            updateUI() {
                // Score update - tycoon game
                document.getElementById('scoreDisplay').textContent = `Score: ${this.gameState.score}`;
                
                // Update health bar
                const healthPercent = (this.gameState.health / this.gameState.maxHealth) * 100;
                document.getElementById('healthFill').style.width = `${healthPercent}%`;
                document.getElementById('healthText').textContent = `‚ù§Ô∏è ${this.gameState.health}/${this.gameState.maxHealth}`;
                
                // Health bar color based on health
                const healthFill = document.getElementById('healthFill');
                if (healthPercent > 60) {
                    healthFill.style.background = 'linear-gradient(90deg, #10b981 0%, #059669 100%)'; // Green
                } else if (healthPercent > 30) {
                    healthFill.style.background = 'linear-gradient(90deg, #f59e0b 0%, #d97706 100%)'; // Orange
                } else {
                    healthFill.style.background = 'linear-gradient(90deg, #ef4444 0%, #dc2626 100%)'; // Red
                }
                
                // Update time counter (countdown from 3:30)
                const elapsedTime = (Date.now() - this.gameState.startTime) / 1000;
                const remainingTime = Math.max(0, this.gameState.timeLimit - elapsedTime);
                const minutes = Math.floor(remainingTime / 60);
                const seconds = Math.floor(remainingTime % 60);
                const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timeCounter').textContent = `‚è±Ô∏è Time: ${timeText}`;
            }

            // checkGameOver fonksiyonu kaldƒ±rƒ±ldƒ± - tycoon oyununda game over yok

            gameOver() {
                // Tycoon oyununda game over sistemi yok - sadece fabrika kurma
                console.log("Tycoon oyununda game over yok");
            }

            // restartGame fonksiyonu kaldƒ±rƒ±ldƒ± - Farcade SDK restart'ƒ± handle ediyor

            resetFactoryVisuals() {
                // T√ºm upgrade objelerini kaldƒ±r
                this.tycoonState.upgradeObjects.forEach(obj => {
                    this.scene.remove(obj);
                });
                this.tycoonState.upgradeObjects = [];
                
                // T√ºm platformlarƒ± yeniden olu≈ütur
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    this.scene.remove(platform);
                });
                this.sceneObjects.tycoonPlatforms = [];
                this.tycoonState.upgradePlatforms = [];
                
                // Platformlarƒ± yeniden olu≈ütur
                this.createTycoonPlatforms();
                
                // Platform renklerini sƒ±fƒ±rla
                this.updatePlatformColors();
                
                // Etiketleri yeniden olu≈ütur
                this.sceneObjects.tycoonPlatforms.forEach(platform => {
                    const upgrade = platform.userData.upgrade;
                    if (!upgrade.bought) {
                        this.createUpgradeLabel(upgrade);
                    }
                });
            }
        }

        // Oyunu ba≈ülat
        window.addEventListener('load', () => {
            new ColdHorizon3D();
        });

        // Farcade SDK event listeners
        window.FarcadeSDK.on('play_again', () => {
            location.reload();
        });

        window.FarcadeSDK.on('toggle_mute', (data) => {
            // Set game audio based on data.isMuted
            console.log('Audio muted:', data.isMuted);
            // For example: setMuted(data.isMuted)
        });
    </script>
</body>
</html>
